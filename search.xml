<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>第 1 章 引论</title>
    <url>/2020/07/11/%E7%AC%AC1%E7%AB%A0%E5%BC%95%E8%AE%BA/</url>
    <content><![CDATA[<h4 id="编译器和解释器"><a href="#编译器和解释器" class="headerlink" title="编译器和解释器"></a>编译器和解释器</h4><h5 id="编译器"><a href="#编译器" class="headerlink" title="编译器"></a>编译器</h5><p>源程序-&gt;(编译器compiler)-&gt;目标程序 (离线offline)<br>输入-&gt;(目标程序)-&gt;输出</p>
<h5 id="解释器"><a href="#解释器" class="headerlink" title="解释器"></a>解释器</h5><p>源程序+输入 -&gt; (解释器interpreter) -&gt; 输出 (在线online)</p>
<h4 id="编译器结构"><a href="#编译器结构" class="headerlink" title="编译器结构"></a>编译器结构</h4><h5 id="一种没有优化的编译器结构"><a href="#一种没有优化的编译器结构" class="headerlink" title="一种没有优化的编译器结构"></a>一种没有优化的编译器结构</h5><p><img src="/picture/%E4%B8%80%E7%A7%8D%E6%B2%A1%E6%9C%89%E4%BC%98%E5%8C%96%E7%9A%84%E7%BC%96%E8%AF%91%E5%99%A8%E7%BB%93%E6%9E%84.png" alt="avatar"></p>
]]></content>
      <categories>
        <category>编译原理</category>
      </categories>
  </entry>
  <entry>
    <title>c++11右值引用</title>
    <url>/2020/06/26/c++11%E5%8F%B3%E5%80%BC%E5%BC%95%E7%94%A8/</url>
    <content><![CDATA[<h4 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h4><p>c++98/03中的左值引用是这样的：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">int</span>&amp; j = i;</span><br></pre></td></tr></table></figure>
<p>这里的int&amp;是对左值进行绑定（但是int&amp;却不能绑定右值），相应的，c++11对右值进行绑定的引用就是右值引用，他的语法是这样的A&amp;&amp;，通过双引号来表示绑定类型为A的右值。通过&amp;&amp;我们就可以很方便的绑定右值了，比如我们可以这样绑定一个右值：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span>&amp;&amp; i = <span class="number">0</span>;</span><br></pre></td></tr></table></figure>
<p>这里我们绑定了一个右值0。右值引用是C++11中新增加的一个很重要的特性，他主是要用来解决C++98/03中遇到的两个问题，第一个问题就是临时对象非必要的昂贵的拷贝操作，第二个问题是在模板函数中如何按照参数的实际类型进行转发。<br>和右值引用相关的概念比较多，比如：右值、纯右值、将亡值、universal references、引用折叠、移动语义、move语义和完美转发等等。<br>下面通过4行代码来理解右值引用相关的概念，理清他们之间的关系，并透彻地掌握C++11的特性–右值引用。</p>
<h4 id="第一行代码"><a href="#第一行代码" class="headerlink" title="第一行代码"></a>第一行代码</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> i = getVar();</span><br></pre></td></tr></table></figure>
<p>上面的代码从getVar()函数获取一个整形值，这行代码一共会产生两种类型的值，一种是左值i，一种是函数getVar()返回的临时值，这个临时值在表达式结束后就销毁了，而左值i在表达式结束后仍然存在，这个临时值就是右值，具体来说是一个纯右值，右值是不具名的。<br>区分左值和右值的一个简单办法是：看能不能对表达式取地址，如果能，则为左值，否则为右值。<br>所有的具名变量或对象都是左值，而匿名变量则是右值，比如，简单的赋值语句：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> i = <span class="number">0</span>;</span><br></pre></td></tr></table></figure>
<p>在这条语句中，i 是左值，0 是字面量，就是右值。具体来说上面的表达式中等号右边的0是纯右值（prvalue），在C++11中所有的值必属于左值、将亡值、纯右值三者之一。<br>比如，非引用返回的临时变量、运算表达式产生的临时变量、原始字面量和lambda表达式等都是纯右值。<br>而将亡值是C++11新增的、与右值引用相关的表达式，比如，将要被移动的对象、T&amp;&amp;函数返回值、std::move返回值和转换为T&amp;&amp;的类型的转换函数的返回值等。将亡值我们会在后面介绍，先看下面代码：</p>
<figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">int</span> j = <span class="number">5</span>;</span><br><span class="line"><span class="built_in">auto</span> f = []&#123; <span class="keyword">return</span> <span class="number">5</span>; &#125;;</span><br></pre></td></tr></table></figure>
<p>上面的代码中5是一个原始字面量，[]{return 5;}是一个lambda表达式，都是属于纯右值，他们的特点是在表达式结束之后就销毁了。</p>
<h4 id="第二行代码"><a href="#第二行代码" class="headerlink" title="第二行代码"></a>第二行代码</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">T&amp;&amp; k = getVar();</span><br></pre></td></tr></table></figure>
<p>这里，getVar()产生的临时值不会像第一行代码那样，在表达式结束之后就销毁了，而是会被“续命”，他的生命周期将会通过右值引用得以延续，和变量k的声明周期一样长。</p>
<h5 id="右值引用的第一个特点"><a href="#右值引用的第一个特点" class="headerlink" title="右值引用的第一个特点"></a>右值引用的第一个特点</h5><p>通过右值引用的声明，右值又“重获新生”，其生命周期与右值引用类型变量的生命周期一样长，只要该变量还活着，该右值临时量将会一直存活下去。让我们通过一个简单的例子来看看右值的生命周期。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> g_constructCount = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">int</span> g_copyConstructCount = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">int</span> g_destructCount = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">A</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    A() &#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">"construct: "</span> &lt;&lt; ++g_constructCount &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    A(<span class="keyword">const</span> A&amp; a) &#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">"copy construct: "</span> &lt;&lt; ++g_copyConstructCount &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ~A() &#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">"destruct: "</span> &lt;&lt; ++g_destructCount &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function">A <span class="title">getA</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> A();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    A a = getA();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在g++编译时设置编译选项<code>-fno-elide-constructors</code>用来关闭返回值优化效果。<br>输出结果：</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">construct:</span> <span class="number">1</span></span><br><span class="line"><span class="attr">copy construct:</span> <span class="number">1</span></span><br><span class="line"><span class="attr">destruct:</span> <span class="number">1</span></span><br><span class="line"><span class="attr">copy construct:</span> <span class="number">2</span></span><br><span class="line"><span class="attr">destruct:</span> <span class="number">2</span></span><br><span class="line"><span class="attr">destruct:</span> <span class="number">3</span></span><br></pre></td></tr></table></figure>
<p>在没有返回值优化的情况下，拷贝构造函数调用了两次，一次是GetA()函数内部创建的对象返回出来构造一个临时对象产生的，另一次是在main函数中构造a对象产生的。第二次的destruct是因为临时对象在构造a对象之后就销毁了。如果开启返回值优化的话，输出结果将是：</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">construct:</span> <span class="number">1</span></span><br><span class="line"><span class="attr">destruct:</span> <span class="number">1</span></span><br></pre></td></tr></table></figure>
<p>可以看到返回值优化将会把临时对象优化掉，但这不是c++标准，是各编译器的优化规则。如果上面的代码中通过右值引用来绑定函数返回值的话，并在编译时设置编译选项<code>-fno-elide-constructors</code>结果会是如何呢？</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    A&amp;&amp; a = getA();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>输出结果：</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">construct:</span> <span class="number">1</span></span><br><span class="line"><span class="attr">copy construct:</span> <span class="number">1</span></span><br><span class="line"><span class="attr">destruct:</span> <span class="number">1</span></span><br><span class="line"><span class="attr">destruct:</span> <span class="number">2</span></span><br></pre></td></tr></table></figure>
<p>通过右值引用，比之前少了一次拷贝构造和一次析构，原因在于右值引用绑定了右值，让临时右值的生命周期延长了。我们可以利用这个特点做一些性能优化，即避免临时对象的拷贝构造和析构，事实上，在c++98/03中，通过常量左值引用也经常用来做性能优化。上面的代码改成：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> A&amp; a = GetA();</span><br></pre></td></tr></table></figure>
<p>输出的结果和右值引用一样，因为常量左值引用是一个“万能”的引用类型，可以接受左值、右值、常量左值和常量右值。需要注意的是普通的左值引用不能接受右值，比如这样的写法是不对的：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">A&amp; a = getA();</span><br></pre></td></tr></table></figure>
<p>上面的代码会报一个编译错误，因为非常量左值引用只能接受左值。</p>
<h5 id="右值引用的第二个特点"><a href="#右值引用的第二个特点" class="headerlink" title="右值引用的第二个特点"></a>右值引用的第二个特点</h5><p>右值引用独立于左值和右值。意思是右值引用类型的变量可能是左值也可能是右值。比如下面的例子：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span>&amp;&amp; var1 = <span class="number">1</span>;</span><br></pre></td></tr></table></figure>
<p>var1类型为右值引用，但var1本身是左值，因为<code>具名变量</code>都是左值。<br>关于右值引用一个有意思的问题是：T&amp;&amp;是什么，一定是右值吗？让我们来看看下面的例子：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">f</span><span class="params">(T&amp;&amp; t)</span></span>;</span><br><span class="line"></span><br><span class="line">f(<span class="number">10</span>); <span class="comment">//t是右值</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> x = <span class="number">10</span>;</span><br><span class="line">f(x); <span class="comment">//t是左值</span></span><br></pre></td></tr></table></figure>
<p>从上面的代码中可以看到，T&amp;&amp;表示的值类型不确定，可能是左值又可能是右值，这一点看起来有点奇怪，这就是右值引用的一个特点。</p>
<h5 id="右值引用的第三个特点"><a href="#右值引用的第三个特点" class="headerlink" title="右值引用的第三个特点"></a>右值引用的第三个特点</h5><p>T&amp;&amp; t在发生自动类型推断的时候，它是未定的引用类型（universal references），如果被一个左值初始化，它就是一个左值；如果它被一个右值初始化，它就是一个右值，它是左值还是右值取决于它的初始化。<br>我们再回过头看上面的代码，对于函数templatevoid f(T&amp;&amp; t)，当参数为右值10的时候，根据universal references的特点，t被一个右值初始化，那么t就是右值；当参数为左值x时，t被一个左值引用初始化，那么t就是一个左值。需要注意的是，仅仅是当发生<code>自动类型推导</code>（如函数模板的类型自动推导，或auto关键字）的时候，T&amp;&amp;才是universal references。再看看下面的例子：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">f</span><span class="params">(T&amp;&amp; param)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Test</span> &#123;</span></span><br><span class="line">Test(Test&amp;&amp; rhs);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>上面的例子中，param是universal reference，rhs是Test&amp;&amp;右值引用，因为模版函数f发生了类型推断，而Test&amp;&amp;并没有发生类型推导，因为Test&amp;&amp;是确定的类型了。<br>正是因为右值引用可能是左值也可能是右值，依赖于初始化，并不是一下子就确定的特点，我们可以利用这一点做很多文章，比如后面要介绍的移动语义和完美转发。<br>这里再提一下引用折叠，正是因为引入了右值引用，所以可能存在左值引用与右值引用和右值引用与右值引用的折叠，C++11确定了引用折叠的规则，规则是这样的：<br><code>所有的右值引用叠加到右值引用上仍然还是一个右值引用；所有的其他引用类型之间的叠加都将变成左值引用。</code></p>
<h4 id="第三行代码"><a href="#第三行代码" class="headerlink" title="第三行代码"></a>第三行代码</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">T(T&amp;&amp; a) : m_val(val)&#123; a.m_val=<span class="literal">nullptr</span>; &#125;</span><br></pre></td></tr></table></figure>
<p>这行代码实际上来自于一个类的构造函数，构造函数的一个参数是一个右值引用，为什么将右值引用作为构造函数的参数呢？在解答这个问题之前我们先看一个例子。如下：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    A() : m_ptr(<span class="keyword">new</span> <span class="keyword">int</span>(<span class="number">0</span>)) &#123; <span class="built_in">cout</span> &lt;&lt; <span class="string">"construct"</span> &lt;&lt; <span class="built_in">endl</span>; &#125;</span><br><span class="line">    A(<span class="keyword">const</span> A&amp; a) : m_ptr(<span class="keyword">new</span> <span class="keyword">int</span>(*a.m_ptr))</span><br><span class="line">    &#123;   <span class="comment">// 深拷贝的拷贝构造函数</span></span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">"copy construct"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    ~A() &#123;</span><br><span class="line">        <span class="keyword">delete</span> m_ptr;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">int</span>* m_ptr;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function">A <span class="title">GetA</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> A();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    A a = GetA();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>输出结果(编译选项<code>-fno-elide-constructors</code>)：</p>
<figure class="highlight dockerfile"><table><tr><td class="code"><pre><span class="line">construct</span><br><span class="line"><span class="keyword">copy</span><span class="bash"> construct</span></span><br><span class="line"><span class="keyword">copy</span><span class="bash"> construct</span></span><br></pre></td></tr></table></figure>
<p>一个带有堆内存的类，必须提供一个深拷贝拷贝构造函数，因为默认的拷贝构造函数是浅拷贝，会发生“指针悬挂”的问题。如果不提供深拷贝的拷贝构造函数，上面的测试代码将会发生错误，内部的m_ptr将会被删除两次，一次是临时右值析构的时候删除一次，第二次外面构造的a对象释放时删除一次，而这两个对象的m_ptr是同一个指针，这就是所谓的指针悬挂问题。<br>提供深拷贝的拷贝构造函数虽然可以保证正确，但是在有些时候会造成额外的性能损耗，因为有时候这种深拷贝是不必要的。比如下面的代码：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">A a = GetA(<span class="literal">false</span>);</span><br></pre></td></tr></table></figure>
<p>上面代码中的GetA函数会返回临时变量，然后通过这个临时变量拷贝构造了一个新的对象a，临时变量在拷贝构造完成之后就销毁了，如果堆内存很大的话，那么，这个拷贝构造的代价会很大，带来了额外的性能损失。每次都会产生临时变量并造成额外的性能损失，有没有办法避免临时变量造成的性能损失呢？答案是肯定的，C++11已经有了解决方法，看看下面的代码。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    A() : m_ptr(<span class="keyword">new</span> <span class="keyword">int</span>(<span class="number">0</span>)) &#123; <span class="built_in">cout</span> &lt;&lt; <span class="string">"construct"</span>&lt;&lt; <span class="built_in">endl</span>; &#125;</span><br><span class="line">    A(<span class="keyword">const</span> A&amp; a) : m_ptr(<span class="keyword">new</span> <span class="keyword">int</span>(*a.m_ptr))</span><br><span class="line">    &#123;   <span class="comment">// 深拷贝的拷贝构造函数</span></span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">"copy construct"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    A(A&amp;&amp; a) : m_ptr(a.m_ptr)</span><br><span class="line">    &#123;</span><br><span class="line">        a.m_ptr = <span class="literal">nullptr</span>;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">"move construct"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    ~A() &#123;</span><br><span class="line">        <span class="keyword">delete</span> m_ptr;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">int</span>* m_ptr;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function">A <span class="title">GetA</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> A();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    A a = GetA();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>输出结果：</p>
<figure class="highlight arduino"><table><tr><td class="code"><pre><span class="line">construct</span><br><span class="line"><span class="built_in">move</span> construct</span><br><span class="line"><span class="built_in">move</span> construct</span><br></pre></td></tr></table></figure>
<p>上面代码只多了一个构造函数，输出结果表明，并没有调用拷贝构造函数，只调用了move construct函数，让我们来看看这个move construct函数：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">A(A&amp;&amp; a) : m_ptr(a.m_ptr)</span><br><span class="line">&#123;</span><br><span class="line">    a.m_ptr = <span class="literal">nullptr</span>;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"move construct"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这个构造函数并没有做深拷贝，仅仅是将指针的所有者转移到了另外一个对象，同时，将参数对象a的指针置为空，这里仅仅是做了浅拷贝，因此，这个构造函数避免了临时变量的深拷贝问题。<br>上面这个函数其实就是移动构造函数，他的参数是一个右值引用类型，这里的A&amp;&amp;表示右值，为什么？前面已经提到，这里没有发生类型推断，是确定的右值引用类型。为什么会匹配到这个构造函数？因为这个构造函数只能接受右值参数，而函数返回值是右值，所以就会匹配到这个构造函数。这里的A&amp;&amp;可以看作是临时值的标识，对于临时值我们仅仅需要做浅拷贝即可，无需再做深拷贝，从而解决了前面提到的临时变量拷贝构造产生的性能损失的问题。这就是所谓的移动语义，右值引用的一个重要作用是用来支持移动语义的。<br>需要注意的一个细节是，我们提供移动构造函数的同时也会提供一个拷贝构造函数，以防止移动不成功的时候还能拷贝构造，使我们的代码更安全。<br>我们知道移动语义是通过右值引用来匹配临时值的，那么，普通的左值是否也能借助移动语义来优化性能呢，那该怎么做呢？事实上C++11为了解决这个问题，提供了std::move方法来将左值转换为右值，从而方便应用移动语义。move是将对象资源的所有权从一个对象转移到另一个对象，只是转移，没有内存的拷贝，这就是所谓的move语义。<br>再看看下面的例子：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">list</span>&lt; <span class="built_in">std</span>::<span class="built_in">string</span>&gt; tokens;</span><br><span class="line"><span class="comment">//省略初始化...</span></span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">list</span>&lt; <span class="built_in">std</span>::<span class="built_in">string</span>&gt; t = tokens; <span class="comment">//这里存在拷贝</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">list</span>&lt; <span class="built_in">std</span>::<span class="built_in">string</span>&gt; tokens;</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">list</span>&lt; <span class="built_in">std</span>::<span class="built_in">string</span>&gt; t = <span class="built_in">std</span>::<span class="built_in">move</span>(tokens); <span class="comment">//这里没有拷贝</span></span><br></pre></td></tr></table></figure>
<p>如果不用std::move，拷贝的代价很大，性能较低。使用move几乎没有任何代价，只是转换了资源的所有权。他实际上将左值变成右值引用，然后应用移动语义，调用移动构造函数，就避免了拷贝，提高了程序性能。如果一个对象内部有较大的对内存或者动态数组时，很有必要写move语义的拷贝构造函数和赋值函数，避免无谓的深拷贝，以提高性能。事实上，C++11中所有的容器都实现了移动语义，方便我们做性能优化。<br>这里也要注意对move语义的误解，move实际上它并不能移动任何东西，它唯一的功能是将一个左值强制转换为一个右值引用。如果是一些基本类型比如int和char[10]定长数组等类型，使用move的话仍然会发生拷贝（因为没有对应的移动构造函数）。所以，move对于含资源（堆内存或句柄）的对象来说更有意义。</p>
<h4 id="第四行代码"><a href="#第四行代码" class="headerlink" title="第四行代码"></a>第四行代码</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;<span class="function"><span class="keyword">void</span> <span class="title">f</span><span class="params">(T&amp;&amp; val)</span></span>&#123; foo(<span class="built_in">std</span>::forward&lt;T&gt;(val)); &#125;</span><br></pre></td></tr></table></figure>
<p>C++11之前调用模板函数时，存在一个比较头疼的问题，如何正确的传递参数。比如：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">forwardValue</span><span class="params">(T&amp; val)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    processValue(val); <span class="comment">//右值参数会变成左值</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">forwardValue</span><span class="params">(<span class="keyword">const</span> T&amp; val)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    processValue(val); <span class="comment">//参数都变成常量左值引用了</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>都不能按照参数的本来的类型进行转发。<br>C++11引入了完美转发：在函数模板中，完全依照模板的参数的类型（即保持参数的左值、右值特征），将参数传递给函数模板中调用的另外一个函数。C++11中的std::forward正是做这个事情的，他会按照参数的实际类型进行转发。看下面的例子：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">processValue</span><span class="params">(<span class="keyword">int</span>&amp; a)</span> </span>&#123; <span class="built_in">cout</span> &lt;&lt; <span class="string">"lvalue"</span> &lt;&lt; <span class="built_in">endl</span>; &#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">processValue</span><span class="params">(<span class="keyword">int</span>&amp;&amp; a)</span> </span>&#123; <span class="built_in">cout</span> &lt;&lt; <span class="string">"rvalue"</span> &lt;&lt; <span class="built_in">endl</span>; &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">forwardValue</span><span class="params">(T&amp;&amp; val)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    processValue(<span class="built_in">std</span>::forward&lt;T&gt;(val));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Testdelcl</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">    forwardValue(i);    <span class="comment">// 传入左值</span></span><br><span class="line">    forwardValue(<span class="number">0</span>);    <span class="comment">// 传入右值</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Testdelcl();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>输出结果：</p>
<figure class="highlight ebnf"><table><tr><td class="code"><pre><span class="line"><span class="attribute">lvaue</span></span><br><span class="line"><span class="attribute">rvalue</span></span><br></pre></td></tr></table></figure>
<p>右值引用T&amp;&amp;是一个universal references，可以接受左值或者右值，正是这个特性让他适合作为一个参数的路由，然后再通过std::forward按照参数的实际类型去匹配对应的重载函数，最终实现完美转发。<br>我们可以结合完美转发和移动语义来实现一个泛型的工厂函数，这个工厂函数可以创建所有类型的对象。具体实现如下：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span>... Args&gt;</span><br><span class="line"><span class="function">T* <span class="title">Instance</span><span class="params">(Args&amp;&amp;... args)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> T(<span class="built_in">std</span>::forward&lt;Args &gt;(args)...);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这个工厂函数的参数是右值引用类型，内部使用std::forward按照参数的实际类型进行转发，如果参数的实际类型是右值，那么创建的时候会自动匹配移动构造，如果是左值则会匹配拷贝构造。</p>
<h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><p>通过4行代码我们知道了什么是右值和右值引用，以及右值引用的一些特点，利用这些特点我们才方便实现移动语义和完美转发。C++11正是通过引入右值引用来优化性能，具体来说是通过移动语义来避免无谓拷贝的问题，通过move语义来将临时生成的左值中的资源无代价的转移到另外一个对象中去，通过完美转发来解决不能按照参数实际类型来转发的问题（同时，完美转发获得的一个好处是可以实现移动语义）。</p>
<h4 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h4><ul>
<li><a href="https://zh.wikipedia.org/wiki/%E5%8F%B3%E5%80%BC%E5%BC%95%E7%94%A8" target="_blank" rel="noopener">维基百科–右值引用</a></li>
<li><a href="https://zhuanlan.zhihu.com/p/54893850" target="_blank" rel="noopener">C++11编程知识：右值引用</a></li>
</ul>
]]></content>
      <categories>
        <category>C++</category>
      </categories>
  </entry>
  <entry>
    <title>第 1 章 计算机的抽象与技术</title>
    <url>/2020/06/21/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%9A%84%E6%8A%BD%E8%B1%A1%E4%B8%8E%E6%8A%80%E6%9C%AF/</url>
    <content><![CDATA[<h4 id="理解程序性能"><a href="#理解程序性能" class="headerlink" title="理解程序性能"></a>理解程序性能</h4><p>程序的性能取决于以下各因素的组合：</p>
<ul>
<li>程序所用的算法</li>
<li>创建程序并将其翻译成机器指令的软件系统</li>
<li>执行机器指令（可能包括I/O操作）的计算机</li>
</ul>
<p>下表总结了硬件和软件对性能产生的影响。<br>| 软件或硬件名称 | 对性能的影响 |<br>| :—-: | :—-: |<br>| 算法 | 决定了源码级语句的数量和I/O操作的数量 |<br>| 编程语言、编译器和体系结构 | 决定了每条源码级语句对应的机器指令数量 |<br>| 处理器和存储系统 | 决定了指令的执行速度 |<br>| I/O系统（硬件和操作系统） | 决定了I/O操作的执行速度 |</p>
<h4 id="计算机体系结构中的-8-个伟大思想"><a href="#计算机体系结构中的-8-个伟大思想" class="headerlink" title="计算机体系结构中的 8 个伟大思想"></a>计算机体系结构中的 8 个伟大思想</h4><ul>
<li>面向摩尔定律的设计：计算机设计通常需要几年时间，因此项目结束时芯片的集成度较项目开始时会翻一番。计算机体系结构设计师应当预测设计完成时的工艺和技术水平，而不是设计开始时的工艺。</li>
<li>使用抽象简化设计：使用抽象来表征不同级别的设计。低层将细节隐藏起来，呈现给高层的只是一个简化的模型。</li>
<li>加速大概率事件：加速大概率事件远比小概率事件更能提高性能。</li>
<li>通过并行提高性能</li>
<li>通过流水线提高性能</li>
<li>通过预测提高性能</li>
<li>存储器层次结构</li>
<li>通过冗余提高可靠性：任何一个物理器件都有可能失效，可以通过增加冗余器件的方式提高系统的<strong>可靠性</strong>。例如，卡车后轴的轮胎每边都有两个，当其中一个发送故障时卡车仍然可以继续行驶。（轮胎修复后又恢复了冗余性）</li>
</ul>
]]></content>
      <categories>
        <category>计算机组成与设计</category>
      </categories>
  </entry>
  <entry>
    <title>Windows10家庭版安装Docker</title>
    <url>/2020/03/26/win10%E5%AE%B6%E5%BA%AD%E7%89%88%E5%AE%89%E8%A3%85docker/</url>
    <content><![CDATA[<p>Docker的install.exe只允许Pro用户与专业版用户执行，家庭版用户安装docker需要另辟溪径。</p>
<h4 id="走的坑一"><a href="#走的坑一" class="headerlink" title="走的坑一"></a>走的坑一</h4><p>网上找到一个运行dockxxx.cmd程序，说是能跳过hydroper-v的检测。不过是较早的帖子（2018），2020年的我通过这种方式，安装失败</p>
<h4 id="走的坑二"><a href="#走的坑二" class="headerlink" title="走的坑二"></a>走的坑二</h4><p>去阿里云镜像安装docker-toolbox，一套走下来，还是失败了。说是桌面软件找不到命令啥的，后面尝试了第三种方式，其实就是我之前装过git，导致Quick Start Docker属性的git路径不对。</p>
<h4 id="成功方式（不成功你过来打我）"><a href="#成功方式（不成功你过来打我）" class="headerlink" title="成功方式（不成功你过来打我）"></a>成功方式（不成功你过来打我）</h4><p>youtube找到了一个教学视频，直接挂youtube链接吧，有空自己再把内容总结一下，最近好忙。<a href="https://www.youtube.com/watch?v=YH3sutAsxEM" target="_blank" rel="noopener">docker安装</a>。我安装失败的原因：</p>
<ul>
<li>BIOS开虚化啊</li>
<li>Quick Start Docker属性的 git 路径要改一下啊。</li>
<li>.iso文件要放到C:\Users\YOUR_USENAME.docker\machine\cache里啊</li>
</ul>
]]></content>
      <categories>
        <category>Docker</category>
      </categories>
  </entry>
  <entry>
    <title>clash配置问题</title>
    <url>/2020/03/19/clash%E9%85%8D%E7%BD%AE%E9%97%AE%E9%A2%98/</url>
    <content><![CDATA[<h3 id="clash配置问题"><a href="#clash配置问题" class="headerlink" title="clash配置问题"></a>clash配置问题</h3><p>由于想学习Go语言(配置个环境都被qiang了)，恩，外面的世界必不可少。。你懂的<br>除了ubuntu，自己的ios、win10都能探索世界了。。ubuntu捣鼓了一周，而自己日常使用ubuntu，clash问题硬是没有解决，困惑不已。<br>今天上午加中午，各种尝试，github搜索各种issue，终于从坑里爬出来了，记录一下。</p>
<ul>
<li>首先！！执行<code>./clash -d .</code>得到的config.yaml文件的内容，这个才是我们所需要的配置文件。我们将供应商购买得到的.yml文件的内容复制到这个文件夹里。。</li>
<li>由于速度问题(你又懂的)，<code>./clash -d .</code>得到的Counry.mmdb文件的内容不全，我们可以自行去网上下载现成的Country.mmdb文件。这里给出一个能下载的地方<a href="https://github.com/JSEcoin/server/blob/master/geoip/GeoIP2-Country.mmdb" target="_blank" rel="noopener">点击这里</a>，将得到的GeoIp2-Country.mmdb更名为Country.mmdb即可。</li>
</ul>
<h3 id="让我的clash后台运行"><a href="#让我的clash后台运行" class="headerlink" title="让我的clash后台运行"></a>让我的clash后台运行</h3><p><code>nohup ./clash -d . &amp;</code></p>
<h3 id="杀死我的clash"><a href="#杀死我的clash" class="headerlink" title="杀死我的clash"></a>杀死我的clash</h3><p><code>ps -ef | grep name</code><br><code>kill -9 id</code></p>
]]></content>
      <categories>
        <category>Config</category>
      </categories>
  </entry>
  <entry>
    <title>std::signal</title>
    <url>/2020/02/16/signal_in_cpp/</url>
    <content><![CDATA[<h3 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h3><p>There are some fantastic explanation details on these websites:</p>
<ul>
<li><a href="https://www.youtube.com/watch?v=83M5-NPDeWs" target="_blank" rel="noopener">https://www.youtube.com/watch?v=83M5-NPDeWs</a></li>
<li><a href="https://en.cppreference.com/w/cpp/utility/program/signal" target="_blank" rel="noopener">https://en.cppreference.com/w/cpp/utility/program/signal</a></li>
</ul>
]]></content>
      <categories>
        <category>C++</category>
      </categories>
  </entry>
  <entry>
    <title>Looping Techniques</title>
    <url>/2020/02/14/Looping%20Techniques/</url>
    <content><![CDATA[<h3 id="Looping-Techniques"><a href="#Looping-Techniques" class="headerlink" title="Looping Techniques"></a>Looping Techniques</h3><p>When looping through dictionaries, the key and corresponding value can be retrieved at the same time using the <code>items()</code> method.</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">knights = &#123;<span class="string">'gallahad'</span>: <span class="string">'the pure'</span>, <span class="string">'robin'</span>: <span class="string">'the brave'</span>&#125;</span><br><span class="line"><span class="keyword">for</span> k, v <span class="keyword">in</span> knight.items():</span><br><span class="line">    print(k, v)</span><br></pre></td></tr></table></figure>

<pre><code>gallahad the pure
robin the brave</code></pre><p>When looping through a sequence, the position index and corresponding value can be retrieved at the same time using the <code>enumerate()</code> function.</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> i, v <span class="keyword">in</span> enumerate([<span class="string">'tic'</span>, <span class="string">'tac'</span>, <span class="string">'toe'</span>]):</span><br><span class="line">    print(i, v)</span><br></pre></td></tr></table></figure>

<pre><code>0 tic
1 tac
2 toe</code></pre><p>To loop over two or more sequences at the same time, the entries can be paired with the <code>zip()</code> function.</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">questions = [<span class="string">'name'</span>, <span class="string">'quest'</span>, <span class="string">'favorite color'</span>]</span><br><span class="line">answers = [<span class="string">'lancelot'</span>, <span class="string">'the holy grail'</span>, <span class="string">'blue'</span>]</span><br><span class="line"><span class="keyword">for</span> q, a <span class="keyword">in</span> zip(questions, answers):</span><br><span class="line">    print(<span class="string">'What is your &#123;0&#125;? It is &#123;1&#125;.'</span>.format(q, a))</span><br></pre></td></tr></table></figure>

<pre><code>What is your name? It is lancelot.
What is your quest? It is the holy grail.
What is your favorite color? It is blue.</code></pre><p>To loop over a sequence in reverse, first specify the sequence in a forward direction and then call the <code>reversed()</code> function.</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> reversed(range(<span class="number">1</span>, <span class="number">10</span>, <span class="number">2</span>)):</span><br><span class="line">    print(i)</span><br></pre></td></tr></table></figure>

<pre><code>9
7
5
3
1</code></pre><p>To loop over a sequence in sorted order, use the <code>sorted()</code> function which returns a new sorted list while leaving the source unaltered.</p>
<p>To loop over a sequence in sorted order, use the sorted() function which returns a new sorted list while leaving the source unaltered.</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">basket = [<span class="string">'apple'</span>, <span class="string">'orange'</span>, <span class="string">'apple'</span>, <span class="string">'pear'</span>, <span class="string">'orange'</span>, <span class="string">'banana'</span>]</span><br><span class="line"><span class="keyword">for</span> f <span class="keyword">in</span> sorted(set(basket)):</span><br><span class="line">    print(f)</span><br></pre></td></tr></table></figure>

<pre><code>apple
banana
orange
pear</code></pre><p>It is sometimes tempting to change a list while you are looping over it; however, it is often simpler and safer to create a new list instead.</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> math</span><br><span class="line">raw_data = [<span class="number">56.2</span>, float(<span class="string">'NaN'</span>), <span class="number">51.7</span>, <span class="number">55.3</span>, <span class="number">52.5</span>, float(<span class="string">'NaN'</span>), <span class="number">47.8</span>]</span><br><span class="line">filter_data = []</span><br><span class="line"><span class="keyword">for</span> value <span class="keyword">in</span> raw_data:</span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> math.isnan(value):</span><br><span class="line">        filter_data.append(value)</span><br><span class="line"></span><br><span class="line">filter_data</span><br></pre></td></tr></table></figure>




<pre><code>[56.2, 51.7, 55.3, 52.5, 47.8]</code></pre>]]></content>
      <categories>
        <category>Python</category>
      </categories>
  </entry>
  <entry>
    <title>Unpacking Argument Lists</title>
    <url>/2020/02/14/UnpackingArgumentLists/</url>
    <content><![CDATA[<h3 id="Unpacking-Argument-Lists"><a href="#Unpacking-Argument-Lists" class="headerlink" title="Unpacking Argument Lists"></a>Unpacking Argument Lists</h3><p>The reverse situation occurs when the arguments are already in a list or tuple but need to be unpacked for a function call requiring separate positional arguments. For instance, the built-in <code>range()</code> function expects separate start and stop arguments. If they are not available separately, write the function call with the <code>*</code>-operator to unpack the arguments out of a list or tuple:</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">list(range(<span class="number">3</span>, <span class="number">6</span>))  <span class="comment"># normal call with separate arguments</span></span><br></pre></td></tr></table></figure>




<pre><code>[3, 4, 5]</code></pre><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">args = [<span class="number">3</span>, <span class="number">6</span>]</span><br><span class="line">list(range(*args)) <span class="comment"># call with arguments unpacked from a lisat</span></span><br></pre></td></tr></table></figure>




<pre><code>[3, 4, 5]</code></pre><p>In the same fashion, dictionaries can deliver keyword arguments with the <code>**</code>-operator:</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">parrot</span><span class="params">(voltage, state=<span class="string">'a stiff'</span>, action=<span class="string">'voom'</span>)</span>:</span></span><br><span class="line">    print(<span class="string">"-- This parrot wouldn't"</span>, action, end=<span class="string">' '</span>)</span><br><span class="line">    print(<span class="string">"if you put"</span>, voltage, <span class="string">"volts through it."</span>, end=<span class="string">' '</span>)</span><br><span class="line">    print(<span class="string">"E's"</span>, state, <span class="string">"!"</span>)</span><br><span class="line"></span><br><span class="line">d = &#123;<span class="string">"voltage"</span>: <span class="string">"four million"</span>, <span class="string">"state"</span>: <span class="string">"bleedin' demised"</span>, <span class="string">"action"</span>: <span class="string">"VOOM"</span>&#125;</span><br><span class="line">parrot(**d)</span><br></pre></td></tr></table></figure>

<pre><code>-- This parrot wouldn&apos;t VOOM if you put four million volts through it. E&apos;s bleedin&apos; demised !</code></pre>]]></content>
      <categories>
        <category>Python</category>
      </categories>
  </entry>
  <entry>
    <title>List Comprehensions</title>
    <url>/2020/02/14/ListComprehensions/</url>
    <content><![CDATA[<h3 id="List-Comprehensions"><a href="#List-Comprehensions" class="headerlink" title="List Comprehensions"></a>List Comprehensions</h3><p><strong>List comprehensions</strong> provide a concise way to create lists. Common applications are to make new lists where each element is the result of some operations applied to each member of another sequence or iterable, or to create a subsequence of those elements that satisfy a certain condition.</p>
<p>For example, assume we want to create a list of squares, like:</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">squares = []</span><br><span class="line"><span class="keyword">for</span> x <span class="keyword">in</span> range(<span class="number">10</span>):</span><br><span class="line">    squares.append(x**<span class="number">2</span>)</span><br><span class="line">    </span><br><span class="line">squares</span><br></pre></td></tr></table></figure>




<pre><code>[0, 1, 4, 9, 16, 25, 36, 49, 64, 81]</code></pre><p>Note that this creates (or overwrites) a variable named x that still exists after the loop completes. We can calculate the list of squares without any side effects using:</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">squares = list(map(<span class="keyword">lambda</span> x: x**<span class="number">2</span>, range(<span class="number">10</span>)))</span><br></pre></td></tr></table></figure>

<p>or, equivalently:</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">squares = [x**<span class="number">2</span> <span class="keyword">for</span> x <span class="keyword">in</span> range(<span class="number">10</span>)]</span><br></pre></td></tr></table></figure>

<p>which is more concise and readable.</p>
<p>A list comprehension consists of brackets containing an expression followed by a for clause, then zero or more for or if clauses. The result will be a new list resulting from evaluating the expression in the context of the for and if clauses which follow it. For example, this listcomp combines the elements of two lists if they are not equal:</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">[(x, y) <span class="keyword">for</span> x <span class="keyword">in</span> [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>] <span class="keyword">for</span> y <span class="keyword">in</span> [<span class="number">3</span>,<span class="number">1</span>,<span class="number">4</span>] <span class="keyword">if</span> x != y]</span><br></pre></td></tr></table></figure>




<pre><code>[(1, 3), (1, 4), (2, 3), (2, 1), (2, 4), (3, 1), (3, 4)]</code></pre><p>and it’s equivalent to:</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">combs = []</span><br><span class="line"><span class="keyword">for</span> x <span class="keyword">in</span> [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]:</span><br><span class="line">    <span class="keyword">for</span> y <span class="keyword">in</span> [<span class="number">3</span>, <span class="number">1</span>, <span class="number">4</span>]:</span><br><span class="line">        <span class="keyword">if</span> x != y:</span><br><span class="line">            combs.append((x, y))</span><br><span class="line"></span><br><span class="line">combs</span><br></pre></td></tr></table></figure>




<pre><code>[(1, 3), (1, 4), (2, 3), (2, 1), (2, 4), (3, 1), (3, 4)]</code></pre><p>Note how the order of the <code>for</code> and <code>if</code> statements is the same in both these snippets.</p>
<p>If the expression is a tuple (e.g. the <code>(x, y)</code> in the previous example), it must be parenthesized.</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">vec = [<span class="number">-4</span>, <span class="number">-2</span>, <span class="number">0</span>, <span class="number">2</span>, <span class="number">4</span>]</span><br><span class="line"><span class="comment"># create a new list with the values doubled</span></span><br><span class="line">[x*<span class="number">2</span> <span class="keyword">for</span> x <span class="keyword">in</span> vec]</span><br></pre></td></tr></table></figure>




<pre><code>[-8, -4, 0, 4, 8]</code></pre><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># filter the list to exclude negative numbers</span></span><br><span class="line">[x <span class="keyword">for</span> x <span class="keyword">in</span> vec <span class="keyword">if</span> x &gt;= <span class="number">0</span>]</span><br></pre></td></tr></table></figure>




<pre><code>[0, 2, 4]</code></pre><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># apply a function to all the elements</span></span><br><span class="line">[abs(x) <span class="keyword">for</span> x <span class="keyword">in</span> vec]</span><br></pre></td></tr></table></figure>




<pre><code>[4, 2, 0, 2, 4]</code></pre><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># call a method on each element</span></span><br><span class="line">freshfruit = [<span class="string">'  banana'</span>, <span class="string">'  loganberry '</span>, <span class="string">'passion fruit  '</span>]</span><br><span class="line">[weapon.strip() <span class="keyword">for</span> weapon <span class="keyword">in</span> freshfruit]</span><br></pre></td></tr></table></figure>




<pre><code>[&apos;banana&apos;, &apos;loganberry&apos;, &apos;passion fruit&apos;]</code></pre><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#create a list of 2-tuples like (number, square)</span></span><br><span class="line">[(x, x**<span class="number">2</span>) <span class="keyword">for</span> x <span class="keyword">in</span> range(<span class="number">6</span>)]</span><br></pre></td></tr></table></figure>




<pre><code>[(0, 0), (1, 1), (2, 4), (3, 9), (4, 16), (5, 25)]</code></pre><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># the tuple must be parenthesized, otherwise an error is raised</span></span><br><span class="line">[x, x**<span class="number">2</span> <span class="keyword">for</span> x <span class="keyword">in</span> range(<span class="number">6</span>)]</span><br></pre></td></tr></table></figure>


<pre><code>  File &quot;&lt;ipython-input-88-702d12ece8a4&gt;&quot;, line 2
    [x, x**2 for x in range(6)]
               ^
SyntaxError: invalid syntax</code></pre><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># flatten a list using a listcomp with two 'for'</span></span><br><span class="line">vec = [[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>], [<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>], [<span class="number">7</span>,<span class="number">8</span>,<span class="number">9</span>]]</span><br><span class="line">[num <span class="keyword">for</span> elem <span class="keyword">in</span> vec <span class="keyword">for</span> num <span class="keyword">in</span> elem]</span><br></pre></td></tr></table></figure>




<pre><code>[1, 2, 3, 4, 5, 6, 7, 8, 9]</code></pre><p>List comprehensions can contain complex expressions and nested functions:</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> math <span class="keyword">import</span> pi</span><br><span class="line">[str(round(pi, i)) <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>, <span class="number">6</span>)]</span><br></pre></td></tr></table></figure>




<pre><code>[&apos;3.1&apos;, &apos;3.14&apos;, &apos;3.142&apos;, &apos;3.1416&apos;, &apos;3.14159&apos;]</code></pre><h3 id="Nested-List-Comprehensions"><a href="#Nested-List-Comprehensions" class="headerlink" title="Nested List Comprehensions"></a>Nested List Comprehensions</h3><p>The initial expression in a list comprehension can be any arbitrary expression, including another list comprehension.</p>
<p>Consider the following example of a 3x4 matrix implemented as a list of 3 lists of length 4:</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">matrix = [</span><br><span class="line">    [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>],</span><br><span class="line">    [<span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>],</span><br><span class="line">    [<span class="number">9</span>, <span class="number">10</span>, <span class="number">11</span>, <span class="number">12</span>],</span><br><span class="line">]</span><br></pre></td></tr></table></figure>

<p>The following list comprehension will transpose rows and columns:</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">[[row[i] <span class="keyword">for</span> row <span class="keyword">in</span> matrix] <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">4</span>)]</span><br></pre></td></tr></table></figure>




<pre><code>[[1, 5, 9], [2, 6, 10], [3, 7, 11], [4, 8, 12]]</code></pre><p>As we saw in the previous section, the nested listcomp is evaluated in the context of the for that follows it, so this example is equivalent to:</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">transposed = []</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">4</span>):</span><br><span class="line">    transposed.append([row[i] <span class="keyword">for</span> row <span class="keyword">in</span> matrix])</span><br><span class="line">    </span><br><span class="line">transposed</span><br></pre></td></tr></table></figure>




<pre><code>[[1, 5, 9], [2, 6, 10], [3, 7, 11], [4, 8, 12]]</code></pre><p>which, in turn, is the same as:</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">transposed = []</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">4</span>):</span><br><span class="line">    <span class="comment"># the following 3 lines implement the nested listcom</span></span><br><span class="line">    transposed_row = []</span><br><span class="line">    <span class="keyword">for</span> row <span class="keyword">in</span> matrix:</span><br><span class="line">        transposed_row.append(row[i])</span><br><span class="line">    transposed.append(transposed_row)</span><br><span class="line"></span><br><span class="line">transposed</span><br></pre></td></tr></table></figure>




<pre><code>[[1, 5, 9], [2, 6, 10], [3, 7, 11], [4, 8, 12]]</code></pre><p>In the real world, you should prefer built-in functions to complex flow statements. The zip() function would do a great job for this use case:</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">list(zip(*matrix))    <span class="comment">#  # call with arguments unpacked from a list</span></span><br></pre></td></tr></table></figure>




<pre><code>[(1, 5, 9), (2, 6, 10), (3, 7, 11), (4, 8, 12)]</code></pre><p>More unpacking arguments lists refer to <a href="http://www.zonepg.com/2019/02/14/UnpackingArgumentLists/" target="_blank" rel="noopener">Unpacking Argument Lists</a></p>
]]></content>
      <categories>
        <category>Python</category>
      </categories>
  </entry>
  <entry>
    <title>Special Parameters On Python3.8</title>
    <url>/2020/02/13/Special_Parameters/</url>
    <content><![CDATA[<h3 id="Special-Parameters"><a href="#Special-Parameters" class="headerlink" title="Special Parameters"></a>Special Parameters</h3><p>For readability and performance, it makes sense to restrict the way arguments can be passed so that a developer need only look at the function definition to determine if items are passed by position, by position or keyword, or by keyword.<br>A function definition may look like:</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">f</span><span class="params">(pos1, pos2, /, pos_or_kwd, *, kwd1, kwd2)</span>:</span></span><br><span class="line"><span class="comment"># pos1 and pos2 mean positionaly only arguments.</span></span><br><span class="line"><span class="comment"># pos_or_kwd are positonaly or keyword arguments.</span></span><br><span class="line"><span class="comment"># And the rest of all are keyword only arguments.</span></span><br></pre></td></tr></table></figure>
<p>where <code>/</code> and <code>*</code> are optional. If used, these symbols indicate the kind of parameter by how the arguments may be passed to the function: positional-only, positional-or-keyword, and keyword-only. Keyword parameters are also referred to as named parameters.</p>
<h4 id="Positional-or-Keyword-Arguments"><a href="#Positional-or-Keyword-Arguments" class="headerlink" title="Positional-or-Keyword Arguments"></a>Positional-or-Keyword Arguments</h4><p>If <code>/</code> and <code>*</code> are not present in the function definition, arguments may be passed to a function by position or by keyword.</p>
<h4 id="Positional-Only-Parameters"><a href="#Positional-Only-Parameters" class="headerlink" title="Positional-Only Parameters"></a>Positional-Only Parameters</h4><p>Positional-only parameters are placed before a <code>/</code> (forward-slash). The <code>/</code> is used to logically separate the positional-only parameters from the rest of the parameters. If there is no <code>/</code> in the function definition, there are no positional-only parameters.</p>
<h4 id="Keyword-Only-Arguments"><a href="#Keyword-Only-Arguments" class="headerlink" title="Keyword-Only Arguments"></a>Keyword-Only Arguments</h4><p>To mark parameters as keyword-only, indicating the parameters must be passed by keyword argument, place an * in the arguments list just before the first keyword-only parameter.</p>
<h4 id="Function-Examples"><a href="#Function-Examples" class="headerlink" title="Function Examples"></a>Function Examples</h4><p>we define these functions in python3.8 terminal:</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="function"><span class="keyword">def</span> <span class="title">standard_arg</span><span class="params">(arg)</span>:</span></span><br><span class="line"><span class="meta">... </span>    print(arg)</span><br><span class="line"><span class="meta">... </span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="function"><span class="keyword">def</span> <span class="title">pos_only_arg</span><span class="params">(arg, /)</span>:</span></span><br><span class="line"><span class="meta">... </span>    print(arg)</span><br><span class="line"><span class="meta">... </span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="function"><span class="keyword">def</span> <span class="title">kwd_only_arg</span><span class="params">(*, arg)</span>:</span></span><br><span class="line"><span class="meta">... </span>    print(arg)</span><br><span class="line"><span class="meta">... </span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="function"><span class="keyword">def</span> <span class="title">combined_example</span><span class="params">(pos_only, /, standard, *, kwd_only)</span>:</span></span><br><span class="line"><span class="meta">... </span>    print(pos_only, standard, kwd_only)</span><br></pre></td></tr></table></figure>
<p>The first function definition, standard_arg, the most familiar form, places no restrictions on the calling convention and arguments may be passed by position or keyword:</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>standard_arg(<span class="number">2</span>)</span><br><span class="line"><span class="number">2</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>standard_arg(arg=<span class="number">2</span>)</span><br><span class="line"><span class="number">2</span></span><br></pre></td></tr></table></figure>
<p>The second function pos_only_arg is restricted to only use positional parameters as there is a / in the function definition:</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>pos_only_arg(<span class="number">1</span>)</span><br><span class="line"><span class="number">1</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>pos_only_arg(arg=<span class="number">1</span>)</span><br><span class="line">Traceback (most recent call last):</span><br><span class="line">  File <span class="string">"&lt;stdin&gt;"</span>, line <span class="number">1</span>, <span class="keyword">in</span> &lt;module&gt;</span><br><span class="line">TypeError: pos_only_arg() got some positional-only arguments passed <span class="keyword">as</span> keyword arguments: <span class="string">'arg'</span></span><br></pre></td></tr></table></figure>
<p>The third function kwd_only_args only allows keyword arguments as indicated by a * in the function definition:</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>kwd_only_arg(<span class="number">3</span>)</span><br><span class="line">Traceback (most recent call last):</span><br><span class="line">  File <span class="string">"&lt;stdin&gt;"</span>, line <span class="number">1</span>, <span class="keyword">in</span> &lt;module&gt;</span><br><span class="line">TypeError: kwd_only_arg() takes <span class="number">0</span> positional arguments but <span class="number">1</span> was given</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>kwd_only_arg(arg=<span class="number">3</span>)</span><br><span class="line"><span class="number">3</span></span><br></pre></td></tr></table></figure>
<p>And the last uses all three calling conventions in the same function definition:</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>combined_example(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>)</span><br><span class="line">Traceback (most recent call last):</span><br><span class="line">  File <span class="string">"&lt;stdin&gt;"</span>, line <span class="number">1</span>, <span class="keyword">in</span> &lt;module&gt;</span><br><span class="line">TypeError: combined_example() takes <span class="number">2</span> positional arguments but <span class="number">3</span> were given</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>combined_example(<span class="number">1</span>, <span class="number">2</span>, kwd_only=<span class="number">3</span>)</span><br><span class="line"><span class="number">1</span> <span class="number">2</span> <span class="number">3</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>combined_example(<span class="number">1</span>, standard=<span class="number">2</span>, kwd_only=<span class="number">3</span>)</span><br><span class="line"><span class="number">1</span> <span class="number">2</span> <span class="number">3</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>combined_example(pos_only=<span class="number">1</span>, standard=<span class="number">2</span>, kwd_only=<span class="number">3</span>)</span><br><span class="line">Traceback (most recent call last):</span><br><span class="line">  File <span class="string">"&lt;stdin&gt;"</span>, line <span class="number">1</span>, <span class="keyword">in</span> &lt;module&gt;</span><br><span class="line">TypeError: combined_example() got some positional-only arguments passed <span class="keyword">as</span> keyword arguments: <span class="string">'pos_only'</span></span><br></pre></td></tr></table></figure>
<p>Finally, consider this function definition which has a potential collision between the positional argument name and <code>**kwds</code> which has <code>name</code> as a key:</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">foo</span><span class="params">(name, **kwds)</span>:</span></span><br><span class="line">    <span class="keyword">return</span> <span class="string">'name'</span> <span class="keyword">in</span> kwds</span><br></pre></td></tr></table></figure>
<p>There is no possible call that will make it return True as the keyword ‘name’ will always to bind to the first parameter. For example:</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>foo(<span class="number">1</span>, **&#123;<span class="string">'name'</span>:<span class="number">2</span>&#125;)</span><br><span class="line">Traceback (most recent call last):</span><br><span class="line">  File <span class="string">"&lt;stdin&gt;"</span>, line <span class="number">1</span>, <span class="keyword">in</span> &lt;module&gt;</span><br><span class="line">TypeError: foo() got multiple values <span class="keyword">for</span> argument <span class="string">'name'</span></span><br><span class="line">&gt;&gt;&gt;</span><br></pre></td></tr></table></figure>
<p>But using <code>/</code> (positional only arguments), it is possible since it allows name as a positional argument and ‘name’ as a key in the keyword arguments:</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="function"><span class="keyword">def</span> <span class="title">foo</span><span class="params">(name, /, **kwds)</span>:</span></span><br><span class="line"><span class="meta">... </span>    <span class="keyword">return</span> <span class="string">'name'</span> <span class="keyword">in</span> kwds</span><br><span class="line"><span class="meta">... </span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>foo(<span class="number">1</span>, **&#123;<span class="string">'name'</span>:<span class="number">2</span>&#125;)</span><br><span class="line"><span class="literal">True</span></span><br></pre></td></tr></table></figure>
<p>In other words, the names of positional-only parameters can be used in **kwds without ambiguity.</p>
<h4 id="Rescap"><a href="#Rescap" class="headerlink" title="Rescap"></a>Rescap</h4><p>The use case will determine which parameters to use in the function definition:</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">f</span><span class="params">(pos1, pos2, /, pos_or_kwd, *, kwd1, kwd2)</span>:</span></span><br></pre></td></tr></table></figure>
<p>As guidance:</p>
<ul>
<li>Use positional-only if you want the name of the parameters to not be available to the user.</li>
<li>Use keyword-only when names have meaning and the function definition is more understandable by being explicit with names or you want to prevent users relying on the position of the argument being passed.</li>
<li>For an API, use positional-only to prevent breaking API changes if the parameter’s name is modified in the future.</li>
</ul>
]]></content>
      <categories>
        <category>Python</category>
      </categories>
  </entry>
  <entry>
    <title>动态规划之最长回文子串</title>
    <url>/2020/01/26/%E6%9C%80%E9%95%BF%E5%9B%9E%E6%96%87%E5%AD%90%E4%B8%B2/</url>
    <content><![CDATA[<p>这是leetcode第五题</p>
<h5 id="算法思路"><a href="#算法思路" class="headerlink" title="算法思路"></a>算法思路</h5><ol>
<li>特判，当 s 的长度为 1 或者 0 时，返回 s。</li>
<li>初始化最长回文子串的开始索引start和最长长度max = 1</li>
<li>初始化dp数组，为n*n，dp[i][j]表示s(i~j)是否为回文串。</li>
<li>初始化dp<ul>
<li>dp[i][i] = 1，表示单个字符一定是回文串</li>
<li>若 i &lt; n - 1 &amp;&amp; s[i] == s[i+1]，表示相邻的字符相同。则dp[i][i+1] = True，并更新最长回文子串的开始索引start=i和长度max=2</li>
</ul>
</li>
<li>此时，从长度 sub_len=3 开始遍历，遍历区间[3, n]，表示所有最长子串可能的长度。因为长度1和2的已经在上一步完成了。对于可能的长度sub_len:<ul>
<li>从索引 i = 0 开始遍历，遍历区间，保证 i+sub_len-1 &lt; len为不越界条件</li>
<li>令子串右侧索引 j = i + sub_len - 1，若满足s[i]==s[j]&amp;&amp;dp[i+1][j-1]==1。表示子串为回文且s[i]==s[j]，说明s(i~j)也是回文。则此时，更新dp[i][j] = 1，并且更新start=i, max = sub_len。</li>
</ul>
</li>
<li>返回s(start~start+max-1)。<h5 id="c-实现代码"><a href="#c-实现代码" class="headerlink" title="c++实现代码"></a>c++实现代码</h5><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">string</span> <span class="title">longestPalindrome</span><span class="params">(<span class="built_in">string</span> s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> len = s.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">if</span> (len == <span class="number">0</span> || len == <span class="number">1</span>)</span><br><span class="line">            <span class="keyword">return</span> s;</span><br><span class="line">        <span class="keyword">int</span> start = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> <span class="built_in">max</span> = <span class="number">1</span>;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; dp(len, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;(len));</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; len; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            dp[i][i] = <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">if</span> (i &lt; len - <span class="number">1</span> &amp;&amp; s[i] == s[i+<span class="number">1</span>])</span><br><span class="line">            &#123;</span><br><span class="line">                start = i;</span><br><span class="line">                <span class="built_in">max</span> = <span class="number">2</span>;</span><br><span class="line">                dp[i][i+<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> sub_len = <span class="number">3</span>; sub_len &lt;= len; sub_len++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i + sub_len - <span class="number">1</span> &lt; len; i++)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">int</span> j = i + sub_len - <span class="number">1</span>;</span><br><span class="line">                <span class="keyword">if</span> (s[i] == s[j] &amp;&amp; dp[i+<span class="number">1</span>][j<span class="number">-1</span>] == <span class="number">1</span>)</span><br><span class="line">                &#123;</span><br><span class="line">                    start = i;</span><br><span class="line">                    <span class="built_in">max</span> = sub_len;</span><br><span class="line">                    dp[i][j] = <span class="number">1</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> s.substr(start, <span class="built_in">max</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
</li>
</ol>
]]></content>
      <categories>
        <category>Data Structures and Algorithm</category>
      </categories>
  </entry>
  <entry>
    <title>寻找两个有序数组的中位数</title>
    <url>/2020/01/25/%E5%AF%BB%E6%89%BE%E4%B8%A4%E4%B8%AA%E6%9C%89%E5%BA%8F%E6%95%B0%E7%BB%84%E7%9A%84%E4%B8%AD%E4%BD%8D%E6%95%B0/</url>
    <content><![CDATA[<p>这是leetcode第四题</p>
<h5 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h5><p>给定两个大小为 m 和 n 的有序数组 nums1 和 nums2。</p>
<p>请你找出这两个有序数组的中位数，并且要求算法的时间复杂度为 O(log(m + n))。</p>
<p>你可以假设 nums1 和 nums2 不会同时为空。</p>
<p>示例 1:</p>
<figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line">nums1 = [<span class="number">1</span>, <span class="number">3</span>]</span><br><span class="line">nums2 = [<span class="number">2</span>]</span><br><span class="line"></span><br><span class="line">则中位数是 <span class="number">2.0</span></span><br></pre></td></tr></table></figure>

<p>示例 2:</p>
<figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line">nums1 = [<span class="number">1</span>, <span class="number">2</span>]</span><br><span class="line">nums2 = [<span class="number">3</span>, <span class="number">4</span>]</span><br><span class="line"></span><br><span class="line">则中位数是 (<span class="number">2</span> + <span class="number">3</span>)/<span class="number">2</span> = <span class="number">2.5</span></span><br></pre></td></tr></table></figure>
<h5 id="算法"><a href="#算法" class="headerlink" title="算法"></a>算法</h5><p>为了解决这个问题，我们需要理解“中位数的作为是什么”。在统计中，中位数被用来：<br><code>将一个几何划分为两个长度相等的子集，其中一个子集中的元素总是大于另一个子集中的元素</code></p>
<p>这其中又分为偶数组和奇数组：</p>
<p>奇数组：[2 3 5](实际上可看作[2 (3/3) 5]) 中位数为3, LMax1 = 3, RMin1 = 3</p>
<p>偶数祖：[1 4 7 9] 中位数为5.5 LMax2 = 4，RMin2 = 7</p>
<p>下面用二分法给出实现代码：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">double</span> <span class="title">findMedianSortedArrays</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums1, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums2)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = nums1.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">int</span> m = nums2.<span class="built_in">size</span>();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (n &gt; m)</span><br><span class="line">            <span class="keyword">return</span> findMedianSortedArrays(nums2, nums1);</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">int</span> c1, c2, lo = <span class="number">0</span>, hi = <span class="number">2</span> * n, LMax1, RMin1, LMax2, RMin2;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (lo &lt;= hi)</span><br><span class="line">        &#123;</span><br><span class="line">            c1 = (lo + hi) / <span class="number">2</span>;</span><br><span class="line">            c2 = m + n - c1;</span><br><span class="line"></span><br><span class="line">            LMax1 = (c1 == <span class="number">0</span>) ? INT_MIN : nums1[(c1<span class="number">-1</span>)/<span class="number">2</span>];</span><br><span class="line">            RMin1 = (c1 == <span class="number">2</span> * n) ? INT_MAX : nums1[c1/<span class="number">2</span>];</span><br><span class="line">            LMax2 = (c2 == <span class="number">0</span>) ? INT_MIN : nums2[(c2<span class="number">-1</span>)/<span class="number">2</span>];</span><br><span class="line">            RMin2 = (c2 == <span class="number">2</span> * m) ? INT_MAX : nums2[c2/<span class="number">2</span>];</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (LMax1 &gt; RMin2)</span><br><span class="line">                hi = c1 - <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (LMax2 &gt; RMin1)</span><br><span class="line">                lo = c1 + <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">        &#125; </span><br><span class="line">        <span class="keyword">return</span> (<span class="built_in">max</span>(LMax1, LMax2) + <span class="built_in">min</span>(RMin1, RMin2)) / <span class="number">2.0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Data Structures and Algorithm</category>
      </categories>
  </entry>
  <entry>
    <title>2020FLAG</title>
    <url>/2020/01/02/2020FLAG/</url>
    <content><![CDATA[<h4 id="2020FLAG"><a href="#2020FLAG" class="headerlink" title="2020FLAG"></a>2020FLAG</h4><h5 id="成绩相关"><a href="#成绩相关" class="headerlink" title="成绩相关"></a>成绩相关</h5><ul>
<li>GPA上3.8，均分上90<h5 id="英语"><a href="#英语" class="headerlink" title="英语"></a>英语</h5></li>
<li>背完六级词、雅思词汇<h5 id="计算机书单"><a href="#计算机书单" class="headerlink" title="计算机书单"></a>计算机书单</h5></li>
<li>梅耶三部曲</li>
<li>吴恩达机器学习课程</li>
<li>《动手深度学习》</li>
<li>《算法》第四版</li>
<li>熟悉Go语言官方文档</li>
<li>leetcode一百题<h5 id="竞赛"><a href="#竞赛" class="headerlink" title="竞赛"></a>竞赛</h5></li>
<li>竞赛拿一次省级以上奖项</li>
</ul>
<h5 id="吴恩达机器学习课程"><a href="#吴恩达机器学习课程" class="headerlink" title="吴恩达机器学习课程"></a>吴恩达机器学习课程</h5><ul>
<li><input checked="" disabled="" type="checkbox"> 吴恩达机器学习课程</li>
</ul>
]]></content>
      <categories>
        <category>feelings</category>
      </categories>
  </entry>
  <entry>
    <title>Summary of 2019</title>
    <url>/2019/12/31/2019%E7%9A%84%E6%9C%80%E5%90%8E%E4%B8%80%E5%A4%A9/</url>
    <content><![CDATA[<div id="hexo-blog-encrypt" data-wpm="Oh, this is an invalid password. Check and try again, please." data-whm="OOPS, these decrypted content may changed, but you can still have a look.">
  <div class="hbe-input-container">
  <input type="password" id="hbePass" placeholder="enter password" />
    <label for="hbePass">enter password</label>
    <div class="bottom-line"></div>
  </div>
  <script id="hbeData" type="hbeData" data-hmacdigest="59e72d7b755845ef6e5066bb5ab7e94a3de67c58d4812aa53630f982a9518ee0">89d5fa131ed53424f07316e1ef0fdc87cbc6a0283ba20f188eebc65a5889c5f697514907e72b40ff6afa9834534982f50425a55875a35b1cc1765babd7182028db27e99d4b8d8cede0bbd71dbfea1ac2c49011e4c266d946408bdd08a4af31d605adcd37f13087b99b4e42c09e495da1b889767186a21dfcd741e351f6e43211b3413342c19af15d213c21a9d8da11788bba29a103f5ebbac0645181c50d2bb87d3ee7319a5334ecc879ee01bb3232790f6e7b01f1f7195e81b20202078d54627635d3170fb968d3ea98de89dd51dad700e0bd3689712aa1d6d6de2d119e9e8cc4c137f28f4e8ca82a19aeed419cf77ff860cdb421022a716056cc852c58a7e590c987d30a8960b9e564a7167e5af488d98354f15c2fe687cc12b94512fb626677ed9b9d4d6756b545ca510543b9791057d11bcc98342a334e18b353dd12aa41692b5446beb0f33a58440c965736a5537e0a8b793314927dbb29db7e882b9bd7463e74e02c80ece20c1455014965ef402912e3ea537a77c39144d6dd6f8a706ae85652a91160027ef3beeeaf095ad621b3074fb5d1dea3309ea896a3009d390d4f82791f2e3ae3f6e1a4963b54a32e6283a5d277ed65093fc261c85058c614eb4f6de4754174f367d7420a581ac1079a0db1467a625e41dccc75b4158a0992567494921da78ab82bb138e936500ca56768446cc1da30008f5621cd7d39329f2d435eb578af837044ed6b5a06bd2ba99b49b0cc356866b06add733b93fa902ec6cff52aad3b21ebeb94fc9b311ec741982e938f4131524a9cfe6a628c18625e343b53c68e20508f612163014c8ead2eb84c66d3b4538ca682998d398f95ce4425049ac744f36a8a2d25bd280cfcc3bed29959f70fb788ebb44d7445dead00f0bc792e9aae2c2ddbf1f77fe3ffdf1e39151f740975973a897366884c1394c6ec9b4e620a0c35bece732eb4401c92813b835babbb523247fcb564fe40ed86252466ec74dfa5d60a5cc40da9e64370f390d2e03c4676b6c8fd1528c66f20d71c0b51947555bfe5aa829977abac489ac84d2c0fab9846c6206d9d35f6b747d4be5d965174e893cd0cc0874aaa3b56c98e8e3c73352dc6b67953172e8c1e707a169468c1f43128b66e12692ade72a3e456f29ebfd9d6c3f26d6f76950176acb1bf620d667ed4ca38a5c9e94d9660bbdd98aefe16dae04acc874ed21af378e39b5a95051d12ab81efe8d8de3dfa4b3ece92a2d8a4e07dc0fac79f53c76447d3c2036fedd85022bceb0d0cb3c03b014042929553344fc97a8649b9c21aa51af716d5605a3822e59e356f113ff7cfe663c67499d6871d2190d3988ee47c4bf802aa0de9761926b4008b01ce42b9108df3c8788ee91570915163e80062f8d14e75681f12acd1a42e533e0fdd71fd71a76c9e2fa6ca0d81d463d9e524973e8b640c3352e7a673c0200375c47ff4fd19d8e21841170b9a85f26a7059667d0f91734e6975ebf8ce76c98a6968a5a0a5a2bf48e199ed79f84fa36bd3c23814625d883cf1c739d2914bf5c9b87acd8233b9dae78ae97cf7078bb984bca7f07844a098ab5244ead9b6e3f4da59c9942e9a965a52781067cc0b25f7bc80732d8bbd9c65e19fff3da9aa3ff8bc867f89157704030e7f3224fcec503d386cd39bff432f732acb9c3750f501ac7f94ec1aec8d8f486910302e077ddd171fdba14e90d9e1f54007cb62153012f23b0f784d7cf2198f04976609eff450f226af24323fc388b4e155b467766718add437d73e7b3edd4f7d65e9839ac33e7a38b1c0b7512b20e6876b5ee3b39c90e842da32f35770ee1c4c12b3b904e90415d386c53e1d2d5a1e7c00dfb58ae0c2da0ddf8a0c6252d9ac2a5fa1d18591140903222cdeb1b1fa5f0e9745fe6dd3803f9057f8e32554af009cf297b9a260ae8eb41a6e2ff7d183b9c06f908ef53e158879b0676719947194db84dfae92a783694aabb507c442d282366b90a3c4558940ee3548323c44435aaa77815ac6b80e99e34fb1ec0e38925ad033b4cfeb08b08b21af739655082145ea8f2fe664949d288b21ce010c81c9d59dc07b0cfdc2e4c78d7ebdc46365c742a548b402bb06817a4e71adccd1e34d61519be05469eb82cf990248999d03df24792d326ce002f50c42617c360cefa21cedfd06296aa555e1077727d455b4df6e967d8bbc2aebd3188a8e8a68f36be53b41fc9af1d510233b0287a85d384a4c12d0891b255264e89fffa516e77d52d4e8927fa86fbe2cd7169579b36ec6ea40e99877968ee2307fbc8a33a3dd68e91e9c131fa61dd39ce3347d722a566238387026b644d269936b4af077a711bef70d212943f3560641b0a8f2f0d9dba33311ea48acfe6b024d559f592f261bec5106d98d5d0526650471a0522e7d782632c05b1f8b33dec2aab643a4196427664360096a1ff3e84e43fe2171d51283c87c2ea7f7eeb255357375904cf29dcf8c19c1089ba76c71b89d43ae434df4baa2ddbd1540f5db0cfb7a48484b931e7b2e83e3bec814992930ef7948c037eb8d8740b0efe11e783e6074238944671d6af194bc3251984a4884bcc52449bca284cbd34d43d6b93050078da5577b8c801672c1ceffaaf31a040dd2176e8f13971ad548dd0ec7bf9f336dc0317266292b6db5ed91bc476230995cd9a329cefd223db55852823fd05db55c9966620682bfc38e3a4f29fdec1ee441fcb0941ea5f25c5a9d4a2907f686c97fffbe6943ce2bbe05ee47c1e1397d6e64c18549225fed97ad367ebb8750d560fced9b41f746ac5e816fd4a612fc0ff56bf618f2949b687cccdadbbe0ebabb655cea80c02c0086a5050ee43cb1007f61e4ec0fc1a737d45e93485f2b525f0ef643d6f7f3dfc7e3524b7a7bf1a68f75cb1e015059caecf65dc93e190ee8cead2c1cf795cd6ac601d97954e3ccfe740b681761971777b3cd05787cffc6d3894b7fceaba9f7d7c73f983f70f080ef24758ad623a046fc1f1b739cceeefa67cda43b671434c20dd30d131cedb4b0249e35888f6681de6743d7fa3ce3258eeb444ffc9cc41c477e7f248cbc335f88c1a0033ed2b5c67597c81d0db6ac0859de61916682a0f8407847640964d20cc6f60cb1f0c0a117d7d66ae8405452c36ee9e1109512f413fd06bc8f35038a52ccbeade2a55ddae5795f3cea3baac7d8556d7357f530a8b029bd0dfe6fac58a3f9ecdd825631ef9a5ec15c0a78665c4cf0ae0aaef14a3b759b0b952e481e8ef464b49366e1c10f5f947444db35371d5aab91e889850064cab6834cc03a077dca79afa863e8592123e07825c4e234f98ef975fe3490e0ebd8ed3f4be74c65a513464f3035b8b0fdafd13ea10c4dc7299abe0f58d16e0e6b74dcd4b282a6d6a599cd8689eed4c0e98c363c6cf0557cc893ca91b229d3db0fba6d18a4fefae7ab6ab21d13985ee2a65c3664fc14ab7726b7bab8228791b30112d188484968a4bceebd5d7e66a8f3d73b11dde116cf06c88aadc2d2f76bacbe4ca60f33d5b8ae0e0d481eb5172b8b6c6b93bdc738505dad17a16b329c17533fd42398c51d934857ac05708ee5751d8ad2fd1d0160969a4357542ece2d82638d8637284815fcf15b584b56d35a7ab4cf2c6f1ff905accfb2925bce0ac049823e7e7dd0369405976bb828e4a45c4ba23d0e8aa4fbe428e7ef82b97ec4c92370771d19165caaf5a85b43c67ab090ff5ad020542ee8a3115feb1936642a3199089031e7078da71901d934757e4b75a4e75c34b979eb5a933d6a30b5a3b18ce4af36dd1b565e34f3c55205e78f10b8bea9e0767af479173df6c4d183dd393a68b487dbbf43092fb05fc974d031ac63cbf909509c2526ad7a532c88f2017d695120e14804964ea457d0baf9e361d372f8bd4d4c7330109876bf6a1cfa34510a550b0a658bf64ca4a068d16912e0d2a23ac988d50852ae68ecad8a6464ec777239d4280816a2046a5ef722d69331587828b7656a65a0f2e17c645458445cbc9b9e54fe254193abcffc32d55432dfdb79b6632c760f2686188d07702f33fd17d2e74e899c9e7d6b9471fb6ad6c2cf6b82926dfce1e1c3975d0c95679f1270173a27688fbe27cf837305adb64289e281e1748f150cb54b10815ba8416eca4ccf7752b74af4b4c20104b95e960895fdd67f6c24e2292282aa595cb057d875eac559b0cca170c47037c1d91841e1bc9069f3adb84b89d1ab44ac14afac60018eb9b286068ee1dda24e2742842420c9901e0acd6621f27463ad0bcb6a29cd48b61f93af767785a27cfcb400190779176624386c804bf45d475148048333fca55b97a85f13b21f1f4acd39eab60491e03adfb6079ad11283cddba81f9a93bac194952a22a46d0ade58329279072e45776d6a51488a6f8554c848e38edadabcf3ee89e9bdabaa90f36be4d564cab7243249653ac3e12b2386020f7b66a520e1ef7160c3bc53d83288aad1bf73aa07a7185d9af8104db5b1660b4ee9a32865f4668db82a598c97c743f12c07e0f303c98b610365134d75f77d0d8195d4c34ff8da47e7d3257c333dfcf9a839bd227b3c809a99edbc1e0e6eaef9a34ea4e1d2f720d679ba5ab29a7ccfc1228d267c29e6ea44faaf3b063236a0e25aae3d43a4e0c0159584e1332281c2fe24d0439b4a9e77655c997fa615e33b62cd331043d601cbe3aaec7ce8185e01bcd39a08e4c42698c8f3a6da9dff86f6b44ea6a7e5ce87b6519a35efed686c29cb877718d5b44a6fba91a738eadf3bcb685c93733975b97432d3d95bc7952f6ed1f1cc20d667a63860ae8ab0377d97b1e5e0eafef30fbb9bf3a0c006af3284e692e76fecb0778770d71120c3f1e672b7eb5b26a7ae4a0023f444e214d5231c46eacc24705b2727f080cdbcd07f39da70dad207925a0ba94a643da0c41a</script>
</div>
<script src="/lib/blog-encrypt.js"></script><link href="/css/blog-encrypt.css" rel="stylesheet" type="text/css">]]></content>
      <categories>
        <category>feelings</category>
      </categories>
  </entry>
  <entry>
    <title>拓扑排序</title>
    <url>/2019/12/29/%E6%8B%93%E6%89%91%E6%8E%92%E5%BA%8F%E4%B8%8E%E5%85%B3%E9%94%AE%E8%B7%AF%E5%BE%84/</url>
    <content><![CDATA[<h4 id="拓扑排序"><a href="#拓扑排序" class="headerlink" title="拓扑排序"></a>拓扑排序</h4><ul>
<li>问题描述<br>拓扑排序(Topological Sort)是从工程领域抽象出来的问题求解方法。一般来说，一个工程大多由若干子工程组成，各项活动之间存在一定的制约关系。<br>例如，一项工程有A、B、C三件事要做，但相互间存在这样的制约关系：A完成之后才能到B，B完成后才能到C，C完成后才能到A。很显然，这种制约关系将导致工程无法进行。<br>为求解此类问题，首先用图来表示工程：用顶点表示活动；用弧表示活动间的关系。这种图称为“AOV网”。</li>
<li>拓扑排序方法及实现<ol>
<li>初始化空栈S。</li>
<li>将AOV网中所有入度为0的顶点压入栈S中。</li>
<li>若S不空，则V=POP(S)，并输出V。</li>
<li>将V的每个后继的入度减1，若其中某个后继的入度变成了0，则将其压入栈S中。</li>
<li>转3</li>
</ol>
</li>
<li>基于邻接矩阵的一种实现<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">TopologicalSortS</span><span class="params">(Graph &amp;G, <span class="keyword">int</span> topoList[])</span></span></span><br><span class="line"><span class="function"></span>&#123;   <span class="comment">// topoList[]数组用于存放拓扑序列</span></span><br><span class="line">    <span class="keyword">int</span> inds[MaxVerNum+<span class="number">1</span>];  <span class="comment">// 定义入度数组</span></span><br><span class="line">    seqStack S;             <span class="comment">// 定义一个顺序栈</span></span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line">    <span class="keyword">int</span> v;                  <span class="comment">// 顶点编号，从1开始</span></span><br><span class="line">    <span class="keyword">int</span> vCount = <span class="number">0</span>;         <span class="comment">// 记录顶点入度为0的顶点数</span></span><br><span class="line">    initStack(S);           <span class="comment">// 初始化栈</span></span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">1</span>; i &lt;= G.VerNum; i++) <span class="comment">// 入度数组初始化</span></span><br><span class="line">        inds[i] = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">1</span>; i &lt;= G.VerNum; i++)</span><br><span class="line">        topoList[i<span class="number">-1</span>] = <span class="number">-1</span>;   <span class="comment">// 初始化顶点编号为-1</span></span><br><span class="line">    GetInDegrees(G, inds);  <span class="comment">// 从邻接矩阵获取图中各个顶点的初始化入度</span></span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">1</span>; i &lt;= G.VerNum; i++) <span class="comment">// 入度为0的顶点入栈</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (inds[i] == <span class="number">0</span>)</span><br><span class="line">            pushStack(S, i);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span> (!StackEmpty(S))</span><br><span class="line">    &#123;</span><br><span class="line">        popStack(S, v);     <span class="comment">// 从栈顶弹出一个入度为0的顶点编号到v</span></span><br><span class="line">        topoList[vCount] = v;   <span class="comment">// 当前入度为0顶点v，加入拓扑序列</span></span><br><span class="line">        vCount++;           <span class="comment">// 已处理顶点（入度为0）数加1</span></span><br><span class="line">        <span class="keyword">for</span> (i = <span class="number">1</span>; i &lt;= G.VerNum; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (G.AdjMatrix[v][i] &gt;= <span class="number">1</span> &amp;&amp; G.AdjMatrix[v][i] &lt; INF &amp;&amp; inds[i] &gt; <span class="number">0</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                inds[i]--;  <span class="comment">// 与v邻接的顶点i的入度减1</span></span><br><span class="line">                <span class="keyword">if</span> (inds[i] == <span class="number">0</span>)   <span class="comment">// 顶点i的入度已经为0，入栈</span></span><br><span class="line">                    pushStack(S, i);</span><br><span class="line">            &#125;         </span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (vCount == G.VerNum)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">`</span><br></pre></td></tr></table></figure>
</li>
</ul>
]]></content>
      <categories>
        <category>Data Structures and Algorithm</category>
      </categories>
  </entry>
  <entry>
    <title>四级押题作文5篇</title>
    <url>/2019/12/04/%E5%9B%9B%E7%BA%A7%E6%8A%BC%E9%A2%98%E4%BD%9C%E6%96%875%E7%AF%87/</url>
    <content><![CDATA[<p>内容摘自知乎<a href="https://zhuanlan.zhihu.com/p/93551714" target="_blank" rel="noopener">四六级考前冲刺—四级押题作文5篇</a></p>
<h3 id="Topic-1：自立"><a href="#Topic-1：自立" class="headerlink" title="Topic 1：自立"></a>Topic 1：自立</h3><ul>
<li>Directions: For this part, you are allowed 30 minutes to write a short essay. You should start your essay with a brief description of the picture and then express your views on self-reliance. You should write at least 120 words but no more than 180words.</li>
<li>“It’s not my fault. Bad grades wouldn’t matter if I had been born rich.”</li>
</ul>
<h5 id="参考范文"><a href="#参考范文" class="headerlink" title="参考范文"></a>参考范文</h5><h5 id="On-Self-reliance"><a href="#On-Self-reliance" class="headerlink" title="On Self-reliance"></a>On Self-reliance</h5><p>As is vividly depicted in the picture, a boy is complaining to his parents that if he had been born with a silver spoon in his mouth, bad grades wouldn’t matter. The picture reflects a serious social problem that nowadays some children are more dependent on their parents. They lack self-reliance.</p>
<p>It is widely acknowledged that self-reliance is indispensable to everyone. For one thing, self-reliance plays a crucial role in the cultivation of creativity. Relying on others means repetition, imitation, and fewer efforts, which may not lead to innovation, an element greatly needed in this era of competition. For another, what is offered by others is not limitless. If children do not depend on themselves, one day when nobody offers them anything anymore, they will fail with regret.</p>
<h3 id="Topic-2：对抗雾霾"><a href="#Topic-2：对抗雾霾" class="headerlink" title="Topic 2：对抗雾霾"></a>Topic 2：对抗雾霾</h3><ul>
<li><p>Directions: In view of the seriousness of the problem, it is high time for children to realize the importance of self-reliance. As for adults, they should encourage their children to confront challenges by themselves; as for children, they should keep “No pain, no gain” in mind and strive for their dreams independently.</p>
</li>
<li><p>As a college student, you are very concerned about air quality; what do you think is the effective way to fight smog?</p>
</li>
</ul>
<h5 id="参考范文-1"><a href="#参考范文-1" class="headerlink" title="参考范文"></a>参考范文</h5><h5 id="On-Fighting-Smog"><a href="#On-Fighting-Smog" class="headerlink" title="On Fighting Smog"></a>On Fighting Smog</h5><p>Recently, smog has become a problem we have to face. There is a growing concern over smog which is believed to threaten people’s health. It is high time that we took some methods to protect ourselves.</p>
<p>People’s views on how to fight smog vary from person to person. Generally speaking, there are three effective ways. First of all, try to reduce the time of outdoor activities, especially when the air quality is not good enough. Secondly, make good use of protective things such as mouth-muffles so that harmful substances would be kept out. Most importantly, protect our environment and cut off the source of smog. Only in this way can we really achieve a long-term success.</p>
<p>From what has been mentioned above, we can come to the conclusion that in order to keep away from smog, we can hide ourselves in a safe area; however, it is much more necessary for us to face the root of the problem bravely and fight against it.</p>
<h3 id="Topic-3：赞美"><a href="#Topic-3：赞美" class="headerlink" title="Topic 3：赞美"></a>Topic 3：赞美</h3><ul>
<li>Directions:  For this part, you are allowed 30 minutes to write a short essay entitled The Importance of Compliments by commenting on Mark Twain’s remark “I can live for two months on a good compliment.” You should write at least 120 words but no more than 180 words.</li>
</ul>
<h5 id="参考范文-2"><a href="#参考范文-2" class="headerlink" title="参考范文"></a>参考范文</h5><h5 id="The-Importance-of-Compliments"><a href="#The-Importance-of-Compliments" class="headerlink" title="The Importance of Compliments"></a>The Importance of Compliments</h5><p>Just as the words Mark Twain even remarked,“I can live for two months on a good compliment.” What he said implies that a compliment is a necessity in our daily life.</p>
<p>As far as I am concerned, compliments are essential to our life for the following three reasons. Firstly, compliments from others boost our confidence and explore our potential. Here is a story to illustrate this point. A child was often scorned by others because he was slow in study. However, his mother never gave him up and always paid him compliments. Little by little, he built up confidence and finally entered a famous university. Secondly, compliments in our daily life bring harmony and happiness to us. What’s more, the significance of compliments has also been proved by psychological studies, which support that a compliment is to the soul what water is to the body.</p>
<p>In summary, good compliments can help us win others’ trust and improve our life. So be generous to give your whole-hearted compliments to the people around you!</p>
<h3 id="Topic-4：应聘国际会议志愿者"><a href="#Topic-4：应聘国际会议志愿者" class="headerlink" title="Topic 4：应聘国际会议志愿者"></a>Topic 4：应聘国际会议志愿者</h3><ul>
<li>Directions: For this part, you are allowed 30 minutes to write an application letter. You should write at least 120 words but no more than 180 words and base your composition on the outline given below in Chinese.<br>假设你是张丽,学校要承办一个国际会议,正在招聘志愿者。你比较感兴趣,想要参加,请根据以下提示写一封申请信。<ol>
<li>应聘的优势</li>
<li>如果被选为志愿者，你将会如何做</li>
</ol>
</li>
</ul>
<h5 id="参考范文-3"><a href="#参考范文-3" class="headerlink" title="参考范文"></a>参考范文</h5><p>Dear Sir or Madam,</p>
<p>It’s my great honor to have the chance to run for the volunteer for the international conference to be hosted by our university. I’m Zhang Li, a sophomore majoring in English. I am sure that I can be qualified for being a volunteer.</p>
<p>First of all, I specialize in English and my fluent oral English will help me a lot. Besides, I have served as a volunteer for two grand sports games. Consequently, I have accumulated sufficient experience. More importantly, I am an energetic person full of passion and enthusiasm for voluntary work. If I were elected, I would go to great lengths to participate in the training and make myself more qualified. Moreover, I would place more importance on team spirit and cooperate with others. To sum up, I would make every effort to finish the mission assigned to me.</p>
<p>Please trust me, and trust your choice. Thank you.</p>
<p>Yours,</p>
<p>Zhang Li</p>
<h3 id="Topic-5：大学生考证热"><a href="#Topic-5：大学生考证热" class="headerlink" title="Topic 5：大学生考证热"></a>Topic 5：大学生考证热</h3><ul>
<li>Direction: For this part, you are allowed 30 minutes to write a short essay entitled Certificate Craze on Campus following the outline given below. You should write at least 120 words but no more than 180 words.<ol>
<li>当今大学生需要通过各种资格认证考试,以获得相应的证书</li>
<li>参加这些考试并获得证书的必要性</li>
<li>我的观点</li>
</ol>
</li>
</ul>
<h5 id="参考范文-4"><a href="#参考范文-4" class="headerlink" title="参考范文"></a>参考范文</h5><h5 id="Certificate-Craze-on-Campus"><a href="#Certificate-Craze-on-Campus" class="headerlink" title="Certificate Craze on Campus"></a>Certificate Craze on Campus</h5><p>Nowadays each college student must have a pile of various certificates upon graduation, such as National Computer Rank Examination Certificate and Accounting Qualification Certificate. Many people believe that it is necessary to get these certificates though we may need to spend much time on the examinations.</p>
<p>First of all, the certificates are the proof of our capabilities to some extent. Besides, with these certificates, it is much easier for graduates to be regarded as qualified applicants in job hunting and attract the attention of various employers. Most importantly, college students can acquire extensive knowledge in the process of preparing for the examinations.</p>
<p>For my part, the certificates are just a means to measure college students’ abilities while the knowledge acquired is truly beneficial and powerful.</p>
]]></content>
      <categories>
        <category>English</category>
      </categories>
  </entry>
  <entry>
    <title>12-3</title>
    <url>/2019/12/03/12-3/</url>
    <content><![CDATA[<h3 id="Modern-Scientific-and-Tecknological-Achievements"><a href="#Modern-Scientific-and-Tecknological-Achievements" class="headerlink" title="Modern Scientific and Tecknological Achievements"></a>Modern Scientific and Tecknological Achievements</h3><p>As western culture came to influence the East at the end of the 16th century and beginning of the 17th century, European science and technology also began to be introduced into China. The development of science and technology was fostered(培养) by successive Chinese governments starting with “westernization movement” in the 20th century. Since 1949, science and technology in China have continued to develop rapidly, particularly in the last several decades.</p>
<h3 id="Atomic-Energy"><a href="#Atomic-Energy" class="headerlink" title="Atomic Energy"></a>Atomic Energy</h3><p>In 1958, China built its first heavy water reactor(反应堆) and cyclotron(回旋加速器), heralding(预示着) China’s entry into the atomic age. The reactor generated 7000-10000 kw of the thermal(热量的) power, and the cyclotron accelerated alpha particles(粒子), producing 2.5 million electron volts. At the same time, China built a high-pressure electrostatic(静电) accelerator(加速器) to accelerate produced its first radioisotope(放射性同位素) with the atomic reactor. The particles produced from the accelerator were used in physical research on atomic nuclei(核心).<br>The production of nuclear(原子能的) energy is a breakthrough in the development of the energy industry. China has mastered the complicated technology associated with exploring and smelting(冶炼) uranium(铀) ore(矿), spliting treating(分割处理) and storing nuclear wastes. China is one of the few countries in the world that have mastered these technologies.</p>
<h3 id="Breakthrough-in-Goldbach’s-Conjecture"><a href="#Breakthrough-in-Goldbach’s-Conjecture" class="headerlink" title="Breakthrough in Goldbach’s Conjecture"></a>Breakthrough in Goldbach’s Conjecture</h3><p>Chinese mathematician, Chen Jingrun, achieved worldwide recognition in 1978 with his calculation of Goldbach’s Conjecture. He preved that any sufficient even number could be the product of a prime number plus at most two other prime numbers(abbreviated as 1+2). The conjecture had remained unresolved for over 200 years. It is now commonly referred to as Chen’s Theorem.</p>
<h3 id="Chang’e-3-Lunar-Lander-and-its-Yutu-Lunar-Rover"><a href="#Chang’e-3-Lunar-Lander-and-its-Yutu-Lunar-Rover" class="headerlink" title="Chang’e-3 Lunar Lander and its Yutu Lunar Rover"></a>Chang’e-3 Lunar Lander and its Yutu Lunar Rover</h3><p>The dramatic soft landing of Chang’e-3 lunar lander on the moon’s Sinus Iridium, or the Bay of Rainbows on 14 Devember 2013 signaled the success of the Chang’e-3 mission, which is comprised of China’s Yutu lunar rover riding piggyback atop a much larger four-legged landing vehicle. The success was hailed as a milestone in the development of China’s space programmes.</p>
]]></content>
      <categories>
        <category>English</category>
      </categories>
  </entry>
  <entry>
    <title>no title</title>
    <url>/2019/11/25/no-title/</url>
    <content><![CDATA[<ul>
<li><p>几天前就在某(bi)乎看到了那篇网易暴力裁员的帖子，到现在已经在各大社交平台刷屏了。阅读过程无不感受到的是资本家的丑恶嘴脸，自己作为一个涉世未深的大学生，无不感到痛心与愤懑。</p>
</li>
<li><p>这里对事件过程已经不想再多批判些什么了，我只想从一个未入职场的大学生的角度说一些东西，成长以来，我们被教育的总是一些“等步入社会，你就知道竞争有多激烈，多残酷”之类。绝大部分人从出生开始，生性何尝不是善良，只是我们总是被教育“职场是残酷的事实”、“社会是残酷的事实”，变得“精明”一点是理所应当。在这样的教育背景以及现实环境下，人在成长过程中便难免会变得复杂起来。确实，优胜劣汰、适者生存是自然规律。放到个人来说，进步的方式有许多种，通过伤害同类来满足进步需求实在是可耻。如果每个人最开始的善良在成长过程中能保留住，从最开始就不断被教育“这个世界是美好的”的思想，最开始就形成良好的社会氛围，又继续这样教育下一代，这必然是一种良性循环，如果这样，我想我们所处的世界又是不一样的世界。反之的情况，也就是我们当下所处的事实。</p>
</li>
<li><p>阅历尚浅，成长以来，也难免遇到困难以及过狗血不已的事情，但知自己善良仍在。与这位被暴力辞职的前网易员工一样，我的专业与我的目标也决定了我不久以后会处在互联网行业这样一个竞争激烈的环境，未来还有许多不可测的困难，但我愿像他一样勇敢地去反抗噩梦，同时必坚定在吸取教训自我进步的过程中坚守善良的决心。</p>
</li>
</ul>
]]></content>
      <categories>
        <category>feelings</category>
      </categories>
  </entry>
  <entry>
    <title>快速排序算法</title>
    <url>/2019/11/25/%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/</url>
    <content><![CDATA[<ul>
<li>快速排序实际上是基于一种二分思想</li>
<li>时间复杂度：O(NlogN)</li>
<li>在处理基准数的左右两边的序列时，用到了递归。<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">quicksort</span><span class="params">(<span class="keyword">int</span> a[], <span class="keyword">int</span> left, <span class="keyword">int</span> right)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i, j, t, temp;</span><br><span class="line">    <span class="keyword">if</span> (left &gt;= right)</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">    temp = a[left]; <span class="comment">// temp存储基准数</span></span><br><span class="line">    i = left;</span><br><span class="line">    j = right;</span><br><span class="line">    <span class="keyword">while</span> (i != j)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 顺序很重要，要从右往左找</span></span><br><span class="line">        <span class="keyword">while</span> (a[j] &gt;= temp &amp;&amp; i &lt; j)</span><br><span class="line">            j--;</span><br><span class="line">        <span class="comment">// 再从左往右找</span></span><br><span class="line">        <span class="keyword">while</span> (a[i] &lt;= temp &amp;&amp; i &lt; j)</span><br><span class="line">            i++;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (i &lt; j)</span><br><span class="line">        &#123;</span><br><span class="line">            t = a[i];</span><br><span class="line">            a[i] = a[j];</span><br><span class="line">            a[j] = t;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 最终将基准数归位</span></span><br><span class="line">    a[left] = a[i];</span><br><span class="line">    a[i] = temp;</span><br><span class="line"></span><br><span class="line">    quicksort(a, left, i - <span class="number">1</span>);  <span class="comment">// 递归处理基准数右边</span></span><br><span class="line">    quicksort(a, i + <span class="number">1</span>, right);  <span class="comment">// 递归处理基准数左边</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> a[<span class="number">100</span>] = &#123; <span class="number">0</span> &#125;;</span><br><span class="line">    <span class="keyword">int</span> n;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; n;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; a[i];</span><br><span class="line"></span><br><span class="line">    quicksort(a, <span class="number">0</span>, n - <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 输出排序后的结果</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; a[i];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
]]></content>
      <categories>
        <category>Data Structures and Algorithm</category>
      </categories>
  </entry>
  <entry>
    <title>迷宫问题</title>
    <url>/2019/11/24/%E8%BF%B7%E5%AE%AB%E9%97%AE%E9%A2%98/</url>
    <content><![CDATA[<ul>
<li>问题描述：给定迷宫（可以为二维数组0-1矩阵），求从起点到目标点路径并求最短步长）</li>
</ul>
<h3 id="DFS解决"><a href="#DFS解决" class="headerlink" title="DFS解决"></a>DFS解决</h3><ul>
<li>深度优先搜索模型可参考博客：<a href="http://www.zonepg.com/2019/11/24/DFS%E8%A7%A3%E5%86%B3%E5%85%A8%E6%8E%92%E5%88%97%E9%97%AE%E9%A2%98/#more" target="_blank" rel="noopener" title="DFS">DFS解决全排列问题</a>.<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n, m, min_d = <span class="number">99999999</span>;</span><br><span class="line"><span class="keyword">int</span> p, q;   <span class="comment">// 目标点坐标</span></span><br><span class="line"><span class="comment">// nextPos为行进方向</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> nextPos[<span class="number">4</span>][<span class="number">2</span>] = &#123; &#123;<span class="number">0</span>, <span class="number">1</span>&#125;,  <span class="comment">// 向右走</span></span><br><span class="line">                   &#123;<span class="number">1</span>, <span class="number">0</span>&#125;,  <span class="comment">// 向下走</span></span><br><span class="line">                   &#123;<span class="number">0</span>, <span class="number">-1</span>&#125;, <span class="comment">// 向左走</span></span><br><span class="line">                   &#123;<span class="number">-1</span>, <span class="number">0</span>&#125;, <span class="comment">// 向上走</span></span><br><span class="line">                 &#125;;</span><br><span class="line"><span class="comment">// 数组a为地图，数组book记录已走过的点</span></span><br><span class="line"><span class="keyword">int</span> a[<span class="number">50</span>][<span class="number">50</span>], book[<span class="number">50</span>][<span class="number">50</span>];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y, <span class="keyword">int</span> <span class="built_in">step</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 到达目标殿</span></span><br><span class="line">    <span class="keyword">if</span> (x == p &amp;&amp; y == q)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 输出可行路径</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; m; j++)</span><br><span class="line">                <span class="built_in">cout</span> &lt;&lt; book[i][j];</span><br><span class="line">            <span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">"step="</span> &lt;&lt; <span class="built_in">step</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 更新最短步长</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">step</span> &lt; min_d)</span><br><span class="line">        &#123;</span><br><span class="line">            min_d = <span class="built_in">step</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 枚举四种走法</span></span><br><span class="line">    <span class="keyword">int</span> tx, ty, k;</span><br><span class="line">    <span class="keyword">for</span> (k = <span class="number">0</span>; k &lt; <span class="number">4</span>; ++k)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 计算下一个点的坐标</span></span><br><span class="line">        tx = x + nextPos[k][<span class="number">0</span>];</span><br><span class="line">        ty = y + nextPos[k][<span class="number">1</span>];</span><br><span class="line">        <span class="comment">// 判断是否越界</span></span><br><span class="line">        <span class="keyword">if</span> (tx &lt; <span class="number">0</span> || tx &gt; n<span class="number">-1</span> || ty &lt; <span class="number">0</span> || ty &gt; m - <span class="number">1</span>)</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        <span class="keyword">if</span> (!a[tx][ty] &amp;&amp; !book[tx][ty])</span><br><span class="line">        &#123;</span><br><span class="line">            book[tx][ty] = <span class="number">1</span>;   <span class="comment">// 标记该点已走过</span></span><br><span class="line">            dfs(tx, ty, <span class="built_in">step</span> + <span class="number">1</span>);  <span class="comment">// 开始尝试下一个点</span></span><br><span class="line">            book[tx][ty] = <span class="number">0</span>;   <span class="comment">// 尝试结束，取消该点标记</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> startx, starty;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"迷宫的行数与列数："</span>;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; n &gt;&gt; m;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"读入迷宫："</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>;j &lt; m; j++)</span><br><span class="line">            <span class="built_in">cin</span> &gt;&gt; a[i][j];</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"读入起点和终点坐标："</span>;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; startx &gt;&gt; starty &gt;&gt; p &gt;&gt; q;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 从起点开始搜索</span></span><br><span class="line">    book[startx][starty] = <span class="number">1</span>;   <span class="comment">// 标记已在路径中</span></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"可行路线为："</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    dfs(startx, starty, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"最短步数："</span>;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; min_d;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</li>
</ul>
<h3 id="BFS解决"><a href="#BFS解决" class="headerlink" title="BFS解决"></a>BFS解决</h3><ul>
<li>广度优先搜索思想是通过“一层一层”扩展的方法来寻求目标点，扩展时发现一个点就将这个点加入到队列中，直至找到目标点。<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> a[<span class="number">50</span>][<span class="number">50</span>], book[<span class="number">50</span>][<span class="number">50</span>];</span><br><span class="line"><span class="keyword">int</span> nextPos[<span class="number">4</span>][<span class="number">2</span>] = &#123;</span><br><span class="line">        &#123; <span class="number">0</span>, <span class="number">1</span> &#125;,   <span class="comment">// 向右走</span></span><br><span class="line">        &#123; <span class="number">1</span>, <span class="number">0</span> &#125;,   <span class="comment">// 向下走</span></span><br><span class="line">        &#123; <span class="number">0</span>, <span class="number">-1</span> &#125;,   <span class="comment">// 向左走</span></span><br><span class="line">        &#123; <span class="number">-1</span>, <span class="number">0</span> &#125;,  <span class="comment">// 向上走</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">note</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">int</span> x;  <span class="comment">// 横坐标</span></span><br><span class="line">    <span class="keyword">int</span> y;  <span class="comment">// 纵坐标</span></span><br><span class="line">    <span class="keyword">int</span> f;  <span class="comment">// 父亲在队列中的编号</span></span><br><span class="line">    <span class="keyword">int</span> s;  <span class="comment">// 步数</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">note</span> <span class="title">que</span>[2500];</span></span><br><span class="line"><span class="keyword">int</span> head, tail;</span><br><span class="line"><span class="keyword">int</span> startx, starty, p, q, tx, ty, flag, m, n;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">bfs</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">while</span> (head &lt; tail)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">0</span>; k &lt;= <span class="number">3</span>; k++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// 计算下一个点的坐标</span></span><br><span class="line">            tx = que[head].x + nextPos[k][<span class="number">0</span>];</span><br><span class="line">            ty = que[head].y + nextPos[k][<span class="number">1</span>];</span><br><span class="line">            <span class="comment">// 判断是否越界</span></span><br><span class="line">            <span class="keyword">if</span> (tx &lt; <span class="number">0</span> || tx &gt; n - <span class="number">1</span> || ty &lt; <span class="number">0</span> || ty &gt; m - <span class="number">1</span>)</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            <span class="comment">// 判断是否是障碍物或者已经在路径中</span></span><br><span class="line">            <span class="keyword">if</span> (!a[tx][ty] &amp;&amp; !book[tx][ty])</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="comment">// 把这个点标记为已经走过</span></span><br><span class="line">                <span class="comment">// 注意宽搜每个点只入队一次，所以和深搜不同，不需要将book还原</span></span><br><span class="line">                book[tx][ty] = <span class="number">1</span>;</span><br><span class="line">                <span class="comment">// 插入点到新的队列中</span></span><br><span class="line">                que[tail].x = tx;</span><br><span class="line">                que[tail].y = ty;</span><br><span class="line">                que[tail].f = head;</span><br><span class="line">                que[tail].s = que[head].s + <span class="number">1</span>;</span><br><span class="line">                tail++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 如果到目标点了，停止扩展，任务结束，退出循环</span></span><br><span class="line">            <span class="keyword">if</span> (tx == p &amp;&amp; ty == q)</span><br><span class="line">            &#123;</span><br><span class="line">                flag = <span class="number">1</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (flag)</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="comment">// 当一个点扩展结束后，head++才能呢个对后面的点再进行扩展</span></span><br><span class="line">        head++;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; m &gt;&gt; n;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m; i++)</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; n; j++)</span><br><span class="line">            <span class="built_in">cin</span> &gt;&gt; a[i][j];</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"输入起点与终点坐标："</span>;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; startx &gt;&gt; starty &gt;&gt; p &gt;&gt; q;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 往队列插入迷宫入口坐标</span></span><br><span class="line">    que[tail].x = startx;</span><br><span class="line">    que[tail].y = starty;</span><br><span class="line">    que[tail].f = <span class="number">-1</span>;</span><br><span class="line">    que[tail].s = <span class="number">0</span>;</span><br><span class="line">    tail++;</span><br><span class="line">    book[startx][starty] = <span class="number">1</span>;</span><br><span class="line">    <span class="comment">// 从起点开始搜索</span></span><br><span class="line">    bfs(startx, starty);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"最短路径长为："</span> &lt;&lt; que[tail<span class="number">-1</span>].s;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"回溯路径："</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = tail - <span class="number">1</span>; i &gt; <span class="number">0</span>;)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">"("</span> &lt;&lt; que[i].x &lt;&lt; <span class="string">", "</span> &lt;&lt; que[i].y &lt;&lt; <span class="string">")"</span>&lt;&lt; <span class="string">"&lt;-"</span>;</span><br><span class="line">        i = que[i].f;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"("</span> &lt;&lt; que[<span class="number">0</span>].x &lt;&lt; <span class="string">", "</span> &lt;&lt; que[<span class="number">0</span>].y &lt;&lt; <span class="string">")"</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
]]></content>
      <categories>
        <category>Data Structures and Algorithm</category>
      </categories>
  </entry>
  <entry>
    <title>DFS解决全排列问题</title>
    <url>/2019/11/24/DFS%E8%A7%A3%E5%86%B3%E5%85%A8%E6%8E%92%E5%88%97%E9%97%AE%E9%A2%98/</url>
    <content><![CDATA[<h3 id="深度优先搜索模型"><a href="#深度优先搜索模型" class="headerlink" title="深度优先搜索模型"></a>深度优先搜索模型</h3><ul>
<li>理解深度优先搜索的关键在于解决“当下该如何做”。至于“下一步如何做”则与“当下该如何做是一样的”。</li>
<li>下面的代码是深度优先搜索的基本模型<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> <span class="built_in">step</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    判断边界</span><br><span class="line">    尝试每一种可能 <span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        继续下一步 dfs(<span class="built_in">step</span>+<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    返回 <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</li>
</ul>
<h3 id="输出1～n的全排列"><a href="#输出1～n的全排列" class="headerlink" title="输出1～n的全排列"></a>输出1～n的全排列</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> a[<span class="number">10</span>], book[<span class="number">10</span>], n, count;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> <span class="built_in">step</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line">    <span class="comment">// 到了第n + 1步，则表示前 n 个数已排列好一次，输出序列</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">step</span> == n + <span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span> (i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">            <span class="built_in">cout</span> &lt;&lt; a[i];</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">        count++;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 此时为第 step 步</span></span><br><span class="line">    <span class="comment">// 按照1～n的顺序一一尝试</span></span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 判断该数是否已经在序列中</span></span><br><span class="line">        <span class="comment">// book[i] == 0表示数 i 未在序列中</span></span><br><span class="line">        <span class="keyword">if</span> (!book[i])</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// 将 i 放入序列中</span></span><br><span class="line">            a[<span class="built_in">step</span>] = i;</span><br><span class="line">            <span class="comment">// 标记为 1，表示 i 已进入序列</span></span><br><span class="line">            book[i] = <span class="number">1</span>;</span><br><span class="line">            <span class="comment">// 开始处理下一个位置</span></span><br><span class="line">            dfs(<span class="built_in">step</span> + <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 这是非常重要的一步，一定要将已经进入序列的 i 收回，才能进行下一次尝试</span></span><br><span class="line">            book[i] = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; n;</span><br><span class="line">    dfs(<span class="number">1</span>);</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"一共有"</span> &lt;&lt; count &lt;&lt; <span class="string">"种排列方式"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Data Structures and Algorithm</category>
      </categories>
  </entry>
  <entry>
    <title>11-24</title>
    <url>/2019/11/24/11-24/</url>
    <content><![CDATA[<p>这的确很难，但还是要向前看</p>
<p>蜕下这层皮，会长出新肉</p>
]]></content>
      <categories>
        <category>feelings</category>
      </categories>
  </entry>
  <entry>
    <title>NexT主题添加一些特效</title>
    <url>/2019/11/18/NexT%E4%B8%BB%E9%A2%98%E6%B7%BB%E5%8A%A0%E4%B8%80%E4%BA%9B%E7%89%B9%E6%95%88/</url>
    <content><![CDATA[<h3 id="设置动态背景"><a href="#设置动态背景" class="headerlink" title="设置动态背景"></a>设置动态背景</h3><ul>
<li>主题配置文件内置4种特效，设置成ture就行。<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Canvas-nest</span></span><br><span class="line"><span class="attr">canvas_nest:</span> <span class="literal">true</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># three_waves</span></span><br><span class="line"><span class="attr">three_waves:</span> <span class="literal">false</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># canvas_lines</span></span><br><span class="line"><span class="attr">canvas_lines:</span> <span class="literal">false</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># canvas_sphere</span></span><br><span class="line"><span class="attr">canvas_sphere:</span> <span class="literal">false</span></span><br></pre></td></tr></table></figure>

</li>
</ul>
<h3 id="添加点击爱心效果"><a href="#添加点击爱心效果" class="headerlink" title="添加点击爱心效果"></a>添加点击爱心效果</h3><ol>
<li>在<code>/themes/next/source/js/src</code>下新建文件 clicklove.js，把如下代码粘贴到clicklove.js文件中：<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">!<span class="function"><span class="keyword">function</span>(<span class="params">e,t,a</span>)</span>&#123;<span class="function"><span class="keyword">function</span> <span class="title">n</span>(<span class="params"></span>)</span>&#123;c(<span class="string">".heart&#123;width: 10px;height: 10px;position: fixed;background: #f00;transform: rotate(45deg);-webkit-transform: rotate(45deg);-moz-transform: rotate(45deg);&#125;.heart:after,.heart:before&#123;content: '';width: inherit;height: inherit;background: inherit;border-radius: 50%;-webkit-border-radius: 50%;-moz-border-radius: 50%;position: fixed;&#125;.heart:after&#123;top: -5px;&#125;.heart:before&#123;left: -5px;&#125;"</span>),o(),r()&#125;<span class="function"><span class="keyword">function</span> <span class="title">r</span>(<span class="params"></span>)</span>&#123;<span class="keyword">for</span>(<span class="keyword">var</span> e=<span class="number">0</span>;e&lt;d.length;e++)d[e].alpha&lt;=<span class="number">0</span>?(t.body.removeChild(d[e].el),d.splice(e,<span class="number">1</span>)):(d[e].y--,d[e].scale+=<span class="number">.004</span>,d[e].alpha-=<span class="number">.013</span>,d[e].el.style.cssText=<span class="string">"left:"</span>+d[e].x+<span class="string">"px;top:"</span>+d[e].y+<span class="string">"px;opacity:"</span>+d[e].alpha+<span class="string">";transform:scale("</span>+d[e].scale+<span class="string">","</span>+d[e].scale+<span class="string">") rotate(45deg);background:"</span>+d[e].color+<span class="string">";z-index:99999"</span>);requestAnimationFrame(r)&#125;<span class="function"><span class="keyword">function</span> <span class="title">o</span>(<span class="params"></span>)</span>&#123;<span class="keyword">var</span> t=<span class="string">"function"</span>==<span class="keyword">typeof</span> e.onclick&amp;&amp;e.onclick;e.onclick=<span class="function"><span class="keyword">function</span>(<span class="params">e</span>)</span>&#123;t&amp;&amp;t(),i(e)&#125;&#125;<span class="function"><span class="keyword">function</span> <span class="title">i</span>(<span class="params">e</span>)</span>&#123;<span class="keyword">var</span> a=t.createElement(<span class="string">"div"</span>);a.className=<span class="string">"heart"</span>,d.push(&#123;<span class="attr">el</span>:a,<span class="attr">x</span>:e.clientX<span class="number">-5</span>,<span class="attr">y</span>:e.clientY<span class="number">-5</span>,<span class="attr">scale</span>:<span class="number">1</span>,<span class="attr">alpha</span>:<span class="number">1</span>,<span class="attr">color</span>:s()&#125;),t.body.appendChild(a)&#125;<span class="function"><span class="keyword">function</span> <span class="title">c</span>(<span class="params">e</span>)</span>&#123;<span class="keyword">var</span> a=t.createElement(<span class="string">"style"</span>);a.type=<span class="string">"text/css"</span>;<span class="keyword">try</span>&#123;a.appendChild(t.createTextNode(e))&#125;<span class="keyword">catch</span>(t)&#123;a.styleSheet.cssText=e&#125;t.getElementsByTagName(<span class="string">"head"</span>)[<span class="number">0</span>].appendChild(a)&#125;<span class="function"><span class="keyword">function</span> <span class="title">s</span>(<span class="params"></span>)</span>&#123;<span class="keyword">return</span><span class="string">"rgb("</span>+~~(<span class="number">255</span>*<span class="built_in">Math</span>.random())+<span class="string">","</span>+~~(<span class="number">255</span>*<span class="built_in">Math</span>.random())+<span class="string">","</span>+~~(<span class="number">255</span>*<span class="built_in">Math</span>.random())+<span class="string">")"</span>&#125;<span class="keyword">var</span> d=[];e.requestAnimationFrame=<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;<span class="keyword">return</span> e.requestAnimationFrame||e.webkitRequestAnimationFrame||e.mozRequestAnimationFrame||e.oRequestAnimationFrame||e.msRequestAnimationFrame||<span class="function"><span class="keyword">function</span>(<span class="params">e</span>)</span>&#123;setTimeout(e,<span class="number">1e3</span>/<span class="number">60</span>)&#125;&#125;(),n()&#125;(<span class="built_in">window</span>,<span class="built_in">document</span>);</span><br></pre></td></tr></table></figure></li>
<li>在<code>\themes\next\layout\_layout.swig</code>文件末尾添加：<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 页面点击小红心 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">"text/javascript"</span> <span class="attr">src</span>=<span class="string">"/js/src/clicklove.js"</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure>
</li>
</ol>
]]></content>
      <categories>
        <category>Config</category>
      </categories>
  </entry>
  <entry>
    <title>使用NexT主题遇到的坑</title>
    <url>/2019/11/18/%E4%BD%BF%E7%94%A8NexT%E4%B8%BB%E9%A2%98%E9%81%87%E5%88%B0%E7%9A%84%E5%9D%91/</url>
    <content><![CDATA[<h3 id="菜单栏显示与连接问题"><a href="#菜单栏显示与连接问题" class="headerlink" title="菜单栏显示与连接问题"></a>菜单栏显示与连接问题</h3><p>昨天晚上发现，自己的菜单栏图标显示有问题，但若在/next的_congfig.yml文件下按照官方document那样设置，图标确实能正常显示。但是，发现点进某一个选项链接会出现Cannot GET /home/%20/这样的错误。<br>找了两小时bug，无奈上床准备休息睡觉。睡前刷一会知乎，搜到这个问题，发现居然是配置的时候多了空格，%20也就是空格的意思。阿，感谢知乎！<br>如下为正确配置方式，在/next/_config.yml文件下：</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">menu:</span></span><br><span class="line">  <span class="attr">home:</span> <span class="string">/||home</span></span><br><span class="line">  <span class="attr">about:</span> <span class="string">/about||user</span></span><br><span class="line">  <span class="attr">tags:</span> <span class="string">/tags||tags</span></span><br><span class="line">  <span class="attr">categories:</span> <span class="string">/categories||th</span></span><br><span class="line">  <span class="attr">archives:</span> <span class="string">/archives||archive</span></span><br><span class="line"><span class="comment">#  schedule: /schedule||calendar</span></span><br><span class="line"><span class="comment">#  sitemap: /sitemap.xml || sitemap</span></span><br><span class="line"><span class="comment">#  commonweal: /404/ || heartbeat</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Enable/Disable menu icons.</span></span><br><span class="line"><span class="attr">menu_icons:</span></span><br><span class="line">  <span class="attr">enable:</span> <span class="literal">true</span></span><br></pre></td></tr></table></figure>
<p>不要有空格！不要有空格！！不要有空格！！！</p>
<h3 id="旁注栏post链接错误"><a href="#旁注栏post链接错误" class="headerlink" title="旁注栏post链接错误"></a>旁注栏post链接错误</h3><p>旁注栏的post与菜单栏的Archives图标不相容bug</p>
]]></content>
      <categories>
        <category>Config</category>
      </categories>
  </entry>
  <entry>
    <title>关于我</title>
    <url>/2019/11/17/%E5%85%B3%E4%BA%8E%E6%88%91/</url>
    <content><![CDATA[<p>本人现就读于HFUTXC，是计算机科学与技术专业的一名18级学生。</p>
<h3 id="关于此站"><a href="#关于此站" class="headerlink" title="关于此站"></a>关于此站</h3><p>很早就有搭建属于自己博客的想法，之前尝试搭建一次，碰到一些问题遂搭建失败，转专业之后更加忙碌，与一些个人情感因素（十月之际，又回归single dog，捂脸.jpg），便将这个想法搁置了下来。两天前的中午，吃完饭的短暂闲暇时光，于是又重新尝试用hexo框架搭建个人博客，这次过程十分顺利，花了几个小时，搭建成功。搭建成功后当时也没怎么写东西，苦于电子实习做收音机（哭.jpg）。两天后的现在，难得的周末时光，有时间写点东西，第一篇文章就当作这自己博客的序言吧。</p>
<h3 id="建站初心"><a href="#建站初心" class="headerlink" title="建站初心"></a>建站初心</h3><p>我的个人博客不仅记录自己的学习笔记，也会写下一些个人生活感悟等。自从上大学以来，看得最多的还是一些技术书本（工科学校工科专业，苦逼工科狗），写的东西也大都是一些学习笔记，很少写一些值得回忆的事情的文字了，感觉自己文字表达能力日益退化。于是搭建了自己的个人博客，通过博客不仅记录一些技术文章，也记录一些有意义的个人经历，以后值得回忆。</p>
<h3 id="过去十八年"><a href="#过去十八年" class="headerlink" title="过去十八年"></a>过去十八年</h3><p>这里我只想记录自己的学业相关，同大多数人一样，我也是按部就班地完成小学、初中的学业，初三最后一个学期努力一把，如愿上了一所普通省重点中学，高中无竞赛经历，仅裸考拿过几个市奖。回想过去的学业时光，自己甚是普通呀。在高考这个重大转折点上，发挥失常，尽管难过，但不得不接受结果。所幸，自己还是能被一所211大学录取。接下来的暑假时光，没什么事情干便想学点东西，在暑假自学了半本高数书，也接触了一点c语言。高考结束以前，对自己想学什么专业也是不太有头绪，比较迷茫。接触编程后，我想自己应该学习计算机专业。但是在志愿结果出来时，自己被录取在了物流管理专业。恩，我知道后面又是挑战——自己得面对是否能转专业的问题。<br>进入大学，大一的时光还是比较轻松的，有许多空余时间可以自己安排，我通过这些空余时间提前自学了一些计算机知识，c语言、c++语言、python、linux、一些算法等，当然全是皮毛，不吹不黑，就当前自己水平来说，仍是菜狗。不过在学习这些东西的过程中，自己更加坚定了自己选择计算机专业的信念，更加充满了对计算机的兴趣。但是还是得兼顾专业排名、专业成绩，焦虑不已，等待一年以后的转专业时间。<br>好在，除了高数以外其他课程都是考前突击，大部分课程也都拿到了不拖后退的成绩，高数两学期98，大一快结束开始转专业填表之际，专业排名前几，感觉自己还是有很大希望转专业到计算机啊！冲冲冲，暑假继续保持高数的学习，大二开学经历转专业高数考试、面试，在各路专业大佬混战的竞争中，我这资质平平的弱弱竟也排在了第三，成功转入了计算机专业。</p>
<h3 id="now"><a href="#now" class="headerlink" title="now"></a>now</h3><p>好吧，现阶段是疯狂补课的阶段，好在对于一些专业课由于大一接触过，学得还算轻松。不过在这个神仙专业，专业前几全是刷分狂魔；课程以外，也有一堆技术大佬。我这弱弱想在这生存下去，还得继续努力啊，希望自己既能保持专业成绩，又能学课程以外自己热爱的东西。</p>
<p>自勉！</p>
]]></content>
      <categories>
        <category>feelings</category>
      </categories>
  </entry>
</search>
